# ---------------------------------------------------------------------------------------------------------------
# piwiPre project
# This program and library is licenced under the European Union Public Licence v1.2 (see LICENCE)
# developed by fabien.battini(at)gmail.com
# ---------------------------------------------------------------------------------------------------------------

# a tool to build a .py out af a picture,
# so that the logo can be embedded into the windows executable

import io
import os
import pathlib
import re
from PIL import Image
from PIL import ImageTk
import base64


class PwpBioImage:
    def __init__(self, content: bytes, img_format: str, filename: str):
        self.buffer: bytes = base64.standard_b64decode(content)
        self.img_format: str = img_format
        self.filename: str = filename

    def tk_photo(self):
        tk_image = ImageTk.PhotoImage(data=self.buffer, format=self.img_format)
        return tk_image

    def pil_image(self):
        si = io.BytesIO(self.buffer)
        i = Image.open(si)
        return i


class PwpEmbedder:

    def __init__(self):
        pass

    @staticmethod
    def convert_data(inf, in_file: str, out_file: str, img_format: str):
        image_name = re.sub(r"[^a-zA-Z0-9_@~àâäéèêëïîôöùûüÿçñÀÂÄÉÈÊËÏÎÔÖÙÛÜŸÇÑ]",
                            "_",
                            os.path.basename(in_file))
        with open(out_file, "w", encoding="utf8") as ouf:
            ouf.write(f"# file generated by pwpImageEmbedder from {in_file}\n")
            ouf.write("from piwiPre.pwpImageEmbedder import PwpBioImage\n")

            line = f'{image_name} = PwpBioImage('
            header = " " * len(line)
            chunk = inf.read(2048)
            buff = b''
            while chunk:
                for i in range(0, len(chunk)):
                    if len(f"{line}{base64.standard_b64encode(buff + chunk[i:i+1])}") > 119:
                        ouf.write(f"{line}{base64.standard_b64encode(buff)}\t# noqa \n")
                        line = header
                        buff = chunk[i:i+1]
                    else:
                        buff += chunk[i:i+1]
                chunk = inf.read(2048)

            ouf.write(f'{line}{base64.standard_b64encode(buff)},\t# noqa\n')
            line = f'{image_name} = ('
            header = " " * len(line)
            ouf.write(f'{header}img_format="{img_format}",\t# noqa\n')
            ouf.write(f'{header}filename="{in_file}")\t# noqa\n')

    def resize_and_convert(self, in_file: str, out_file: str, width: int, height: int):
        src = Image.open(in_file)
        img_format = pathlib.Path(in_file).suffix[1:]
        src.thumbnail((width, height), resample=Image.Resampling.LANCZOS)
        buffer = io.BytesIO()
        src.save(buffer, format=img_format)
        b3 = io.BytesIO(buffer.getvalue())
        self.convert_data(b3, in_file, out_file, img_format)

    def convert(self, in_file: str, out_file: str):
        src = Image.open(in_file)
        img_format = pathlib.Path(in_file).suffix[1:]
        buffer = io.BytesIO()
        src.save(buffer, format=img_format)
        b3 = io.BytesIO(buffer.getvalue())
        self.convert_data(b3, in_file, out_file, img_format)
        return


if __name__ == "__main__":
    embedder = PwpEmbedder()
    embedder.resize_and_convert("../pwpLogo.png", "../piwiPre/pwpLogoSmall.py", 50, 29)
