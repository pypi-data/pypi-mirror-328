Metadata-Version: 2.1
Name: endecrypter
Version: 1.20.21
Summary: A comprehensive encryption/decryption library
Home-page: https://github.com/Elabsurdo984/EnDecrypter.git
Author: Elabsurdo984
Author-email: matiassfernandez00@gmail.com
License: GPL
Project-URL: Source, https://github.com/Elabsurdo984/EnDecrypter
Requires-Python: >=3.12
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: pycryptodome>=3.21.0
Requires-Dist: numpy>=2.2.3

# EnDecrypter

Una biblioteca Python que proporciona una colecci√≥n completa de algoritmos de cifrado, incluyendo tanto m√©todos cl√°sicos como modernos, con una interfaz simple y consistente.

## Tabla de Contenidos
- [EnDecrypter](#endecrypter)
  - [Tabla de Contenidos](#tabla-de-contenidos)
  - [Instalaci√≥n](#instalaci√≥n)
    - [Requisitos](#requisitos)
  - [Caracter√≠sticas](#caracter√≠sticas)
  - [Uso](#uso)
    - [Cifrado C√©sar](#cifrado-c√©sar)
    - [Cifrado Monoalfab√©tico](#cifrado-monoalfab√©tico)
    - [Cifrado Polialfab√©tico](#cifrado-polialfab√©tico)
    - [Cifrado por Transposici√≥n](#cifrado-por-transposici√≥n)
    - [Cifrado Hill](#cifrado-hill)
    - [Maquina Enigma](#maquina-enigma)
    - [Cifrado DES](#cifrado-des)
    - [Cifrado RC4](#cifrado-rc4)
    - [Cifrado RC5](#cifrado-rc5)
    - [Cifrado RC6](#cifrado-rc6)
    - [Triple DES](#triple-des)
    - [Salsa20](#salsa20)
    - [ChaCha20](#chacha20)
    - [Utilidades Binarias](#utilidades-binarias)
  - [Documentaci√≥n Detallada](#documentaci√≥n-detallada)
    - [Comparativa de Cifrados](#comparativa-de-cifrados)
  - [Contribuir](#contribuir)
    - [Gu√≠a de Contribuci√≥n](#gu√≠a-de-contribuci√≥n)
  - [Licencia](#licencia)

## Instalaci√≥n

```bash
pip install endecrypter
```

### Requisitos
- Python 3.12+
- pycryptodome (para cifrados DES, 3DES)
- NumPy (Para cifrados Hill, Enigma)

## Caracter√≠sticas

- üìú **Cifrados Cl√°sicos**
  - C√©sar
  - Monoalfab√©tico
  - Polialfab√©tico (Vigen√®re)
  - Transposici√≥n (Rail Fence)
  - Hill
  - Enigma
  
- üîê **Cifrados Modernos**
  - DES
  - RC4
  - RC5
  - RC6
  - 3DES
  - Salsa20
  
- üõ†Ô∏è **Utilidades**
  - Conversi√≥n Binaria

## Uso

### Cifrado C√©sar

El cifrado C√©sar es un tipo de cifrado por sustituci√≥n en el que cada letra del texto claro se reemplaza por una letra que se encuentra un n√∫mero fijo de posiciones m√°s adelante en el alfabeto. Este n√∫mero fijo es conocido como **"desplazamiento"**.

```python
from endecrypter import CaesarCipher

# Cifrar un mensaje
mensaje = "Hello World"
desplazamiento = 3
cifrado = CaesarCipher.encrypt_caesar(mensaje, desplazamiento)
print(f"Texto cifrado: {cifrado}")  # Khoor Zruog

# Descifrar el mensaje
descifrado = CaesarCipher.decrypt_caesar(cifrado, desplazamiento)
print(f"Texto descifrado: {descifrado}")  # Hello World
```

### Cifrado Monoalfab√©tico

El **cifrado monoalfab√©tico** es un tipo de cifrado por sustituci√≥n en el que cada letra del texto claro se sustituye por una letra diferente del alfabeto, pero siempre de manera fija. Es decir, cada letra del alfabeto se reemplaza por otra letra del alfabeto de forma constante, sin importar su posici√≥n en el mensaje.

```python
from endecrypter import MonoalphabeticCipher

# Generar alfabeto de sustituci√≥n
alfabeto = MonoalphabeticCipher.generate_substitution_alphabet()

# Cifrar
mensaje = "Hello World"
cifrado = MonoalphabeticCipher.encrypt_monoalphabetic(mensaje, alfabeto)
print(f"Texto cifrado: {cifrado}")

# Descifrar
descifrado = MonoalphabeticCipher.decrypt_monoalphabetic(cifrado, alfabeto)
print(f"Texto descifrado: {descifrado}")  # Hello World
```

### Cifrado Polialfab√©tico

El **cifrado polialfab√©tico** es un tipo de cifrado por sustituci√≥n en el que se utilizan varios alfabetos para cifrar un mensaje, en lugar de un solo alfabeto como en el cifrado monoalfab√©tico. Esto hace que el cifrado sea m√°s seguro, ya que cada letra del texto claro puede ser sustituida por una letra diferente seg√∫n una serie de reglas, lo que dificulta la tarea de los atacantes.

```python
from endecrypter import PolyalphabeticCipher

# Cifrar
mensaje = "HELLO WORLD"
clave = "KEY"
cifrado = PolyalphabeticCipher.encrypt_polyalphabetic(mensaje, clave)
print(f"Texto cifrado: {cifrado}")

# Descifrar
descifrado = PolyalphabeticCipher.decrypt_polyalphabetic(cifrado, clave)
print(f"Texto descifrado: {descifrado}")  # HELLO WORLD
```

### Cifrado por Transposici√≥n

El **cifrado de transposici√≥n** es un tipo de cifrado en el que el orden de las letras del mensaje se reorganiza, pero sin cambiar las propias letras. A diferencia de los cifrados por sustituci√≥n (como el cifrado C√©sar o monoalfab√©tico), que modifican las letras del mensaje, el cifrado de transposici√≥n solo altera la posici√≥n de las letras.

```python
from endecrypter import TranspositionCipher

# Cifrar
mensaje = "Hello World"
rieles = 3
cifrado = TranspositionCipher.encrypt_transposition(mensaje, rieles)
print(f"Texto cifrado: {cifrado}")

# Descifrar
descifrado = TranspositionCipher.decrypt_transposition(cifrado, rieles)
print(f"Texto descifrado: {descifrado}")  # Hello World
```

### Cifrado Hill

El **cifrado Hill** es un algoritmo de cifrado por sustituci√≥n polialfab√©tica que utiliza √°lgebra lineal para cifrar y descifrar mensajes. Fue desarrollado por Lester S. Hill en 1929 y es uno de los primeros m√©todos de cifrado en usar matrices. Este cifrado se basa en la idea de tratar el texto claro como un conjunto de vectores y las letras del mensaje se representan num√©ricamente, generalmente usando el sistema de asignaci√≥n A=0, B=1, C=2, y as√≠ sucesivamente.

```python
from endecrypter import HillCipher

# Matriz clave 2x2
key = [
    [2, 3],
    [3, 6]
]

try:
    # Aseguramos que el texto sea un string
    text = "hello"
    print(f"Texto original: {text}")
    
    encrypted, padding_count = HillCipher.encrypt_hill(text, key)
    print(f"Texto encriptado: {encrypted}")
    
    decrypted = HillCipher.decrypt_hill(encrypted, key, padding_count)
    print(f"Texto desencriptado: {decrypted}")

except Exception as e:
    print(f"Error: {type(e).__name__} - {str(e)}")
```

### Maquina Enigma

Un sistema de cifrado mecanogr√°fico usado por los alemanes durante la Segunda Guerra Mundial. Utiliza una serie de rotores el√©ctricos para cifrar y descifrar el texto. Aunque es un sistema de cifrado m√°s complejo, sigue siendo considerado "cl√°sico".

```python
from endecrypter import EnigmaMachine, ROTOR_I, ROTOR_II, ROTOR_III, REFLECTOR_B

# Crear una instancia de la m√°quina Enigma
enigma = EnigmaMachine(
    rotor_configs=[ROTOR_I, ROTOR_II, ROTOR_III],
    reflector=REFLECTOR_B,
    ring_settings=[1, 1, 1],  # Configuraci√≥n de anillos
    initial_positions=['A', 'A', 'A']  # Posiciones iniciales
)

# Encriptar un mensaje
mensaje = "HELLOWORLD"
mensaje_cifrado = enigma.encrypt(mensaje)
print(f"Mensaje original: {mensaje}")
print(f"Mensaje cifrado: {mensaje_cifrado}")

# Para descifrar, configura una nueva m√°quina con los mismos ajustes
enigma_descifrado = EnigmaMachine(
    rotor_configs=[ROTOR_I, ROTOR_II, ROTOR_III],
    reflector=REFLECTOR_B,
    ring_settings=[1, 1, 1],
    initial_positions=['A', 'A', 'A']
)

mensaje_descifrado = enigma_descifrado.encrypt(mensaje_cifrado)
print(f"Mensaje descifrado: {mensaje_descifrado}")
```

### Cifrado DES

El **cifrado DES** (Data Encryption Standard) es un algoritmo de cifrado sim√©trico que utiliza una clave de 56 bits para cifrar bloques de 64 bits de datos. Funciona dividiendo el bloque de datos en dos mitades de 32 bits, y luego realiza 16 rondas de transformaci√≥n utilizando operaciones de sustituci√≥n y permutaci√≥n, aplicando la clave en cada ronda. La estructura del algoritmo sigue el modelo de red de Feistel, donde una mitad del bloque se modifica en funci√≥n de la otra. Aunque DES fue un est√°ndar de seguridad ampliamente utilizado, su clave corta lo hace vulnerable a ataques de fuerza bruta, y fue reemplazado por el m√°s seguro AES.

```python
from endecrypter import DESCipher

# La clave debe ser de 8 bytes
clave = b"secretky"

# Cifrar
mensaje = "Hello World"
cifrado = DESCipher.encrypt_des(mensaje, clave)
print(f"Texto cifrado (bytes): {cifrado}")

# Descifrar
descifrado = DESCipher.decrypt_des(cifrado, clave)
print(f"Texto descifrado: {descifrado}")  # Hello World
```

### Cifrado RC4

**RC4** es un algoritmo de cifrado sim√©trico de flujo, desarrollado por Ron Rivest en 1987. Funciona generando una secuencia de claves pseudoaleatorias de longitud variable a partir de una clave inicial, que luego se combina con el texto claro mediante una operaci√≥n de XOR (o exclusivo). El proceso de generaci√≥n de la secuencia de claves se basa en una tabla de estado que se va modificando continuamente durante la operaci√≥n, lo que permite cifrar los datos bit por bit. Aunque RC4 fue ampliamente utilizado en protocolos como SSL/TLS y WEP, su seguridad ha sido comprometida por diversas vulnerabilidades.

```python
from endecrypter import RC4Cipher

# La clave puede ser de cualquier longitud
clave = b"mi_clave_secreta"

# Cifrar
mensaje = "Hello World"
cifrado = RC4Cipher.encrypt_rc4(mensaje, clave)
print(f"Texto cifrado (bytes): {cifrado}")

# Descifrar
descifrado = RC4Cipher.decrypt_rc4(cifrado, clave)
print(f"Texto descifrado: {descifrado}")  # Hello World
```

### Cifrado RC5

**RC5** es un algoritmo de cifrado sim√©trico de bloques desarrollado por Ron Rivest en 1994. Funciona mediante una estructura de red de Feistel, y permite personalizar varios par√°metros clave, como el tama√±o de la clave, el n√∫mero de rondas y el tama√±o del bloque de datos, lo que le da flexibilidad y adaptabilidad a diferentes aplicaciones. El algoritmo usa una clave de longitud variable (de 0 a 2040 bits) y cifra bloques de datos de 32, 64 o 128 bits. RC5 aplica una serie de transformaciones, que incluyen permutaciones y sustituciones, a los bloques de datos durante un n√∫mero de rondas definido por la clave.

```python
from endecrypter import RC5Cipher

# Generar una clave aleatoria de 16 bytes
key = RC5Cipher.generate_key(16)

# Texto a cifrar
mensaje = "Texto secreto"

try:
    # Cifrar el mensaje
    datos_cifrados = RC5Cipher.encrypt_rc5(mensaje, key)
    print("Mensaje cifrado: {datos_cifrados}")

    # Descifrar el mensaje
    texto_descifrado = RC5Cipher.decrypt_rc5(datos_cifrados, key)
    print(f"Mensaje descifrado: {texto_descifrado}")

except Exception as e:
    print(f"Error: {e}")
```

### Cifrado RC6

**RC6** es un algoritmo de cifrado sim√©trico de bloques desarrollado por Ron Rivest, Mahesh Rao, y Robert Sidney en 1997 como una extensi√≥n de RC5. RC6 fue uno de los finalistas en la competici√≥n para seleccionar el nuevo est√°ndar de cifrado AES, aunque no fue elegido. Al igual que RC5, RC6 utiliza una estructura de red de Feistel, pero con mejoras que lo hacen m√°s seguro y eficiente. RC6 permite bloques de datos de 128 bits y soporta claves de longitud variable (de 128, 192 o 256 bits). Adem√°s, utiliza una versi√≥n extendida de las operaciones de permutaci√≥n y sustituci√≥n, y un n√∫mero variable de rondas (de 20, 12 o 8, dependiendo de la longitud de la clave). A diferencia de RC5, RC6 incorpora un multiplicador en sus transformaciones, lo que aumenta su seguridad frente a ataques. Aunque no fue adoptado como AES, sigue siendo una opci√≥n robusta para aplicaciones que requieren un alto nivel de seguridad.

```python
from endecrypter import RC6Cipher

rc6 = RC6Cipher()
key = rc6.generate_key(16)
texto = "Mensaje secreto"

# Cifrar
cifrado = rc6.encrypt_rc6(texto, key)
print(cifrado)


# Descifrar
descifrado = rc6.decrypt_rc6(cifrado, key)
print(descifrado)
```

### Triple DES

**Triple DES (3DES)** es una variante del algoritmo DES dise√±ada para mejorar la seguridad de DES, que se volvi√≥ vulnerable debido a la corta longitud de su clave. 3DES aplica el algoritmo DES tres veces de manera secuencial sobre el mismo bloque de datos, utilizando tres claves diferentes (o la misma clave en algunos casos). Este proceso puede realizarse de tres formas diferentes: **EDE** (Encrypt-Decrypt-Encrypt), donde primero se cifra, luego se descifra y finalmente se cifra de nuevo, lo que mejora considerablemente la seguridad. Con tres aplicaciones de DES, 3DES efectivamente aumenta el tama√±o de la clave a 168 bits (o 112 bits si se reutilizan algunas claves), lo que hace m√°s dif√≠cil de romper mediante ataques de fuerza bruta. Aunque 3DES fue una mejora significativa sobre DES, sigue siendo relativamente lento en comparaci√≥n con algoritmos m√°s modernos, como **AES**, y debido a su vulnerabilidad a ciertos ataques, ha sido descontinuado para muchas aplicaciones y reemplazado por AES.

```python
from endecrypter import TripleDESCipher

# Generar una clave segura
key = TripleDESCipher.generate_key()

# Cifrar un mensaje
mensaje = "Informaci√≥n confidencial"
try:
    encrypted_data = TripleDESCipher.encrypt(mensaje, key)
    print("Mensaje cifrado exitosamente")

    # Descifrar el mensaje
    decrypted_text = TripleDESCipher.decrypt(encrypted_data, key)
    print(f"Mensaje descifrado: {decrypted_text}")

except ValueError as e:
    print(f"Error: {e}")
```

### Salsa20

El cifrado **Salsa20** es un algoritmo de cifrado sim√©trico de flujo (stream cipher) dise√±ado por el cript√≥grafo Daniel J. Bernstein. Forma parte de la familia de cifrados de flujo que transforman los datos en bloques de texto plano en texto cifrado mediante una secuencia de clave generada de manera pseudoaleatoria.

```python
from endecrypter import Salsa20Cipher

cipher = Salsa20Cipher
key = cipher.generate_key() # Genera una clave aleatoria de 32 bytes

# Cifrar
texto = "Hola mundo!"
encrypted, nonce = cipher.encrypt(texto, key)
print(encrypted)

# Descifrar
decrypt = cipher.decrypt(encrypted, key, nonce)
print(decrypt)
```

### ChaCha20

El cifrado **ChaCha20** es un algoritmo de cifrado sim√©trico basado en un cifrador de flujo (stream cipher). Fue dise√±ado por el cript√≥grafo Daniel J. Bernstein en 2008 como una variante m√°s segura y eficiente del algoritmo Salsa20, que √©l mismo tambi√©n hab√≠a creado. La principal ventaja de ChaCha20 sobre otros algoritmos como el RC4 o el mismo Salsa20 es su resistencia a ciertos tipos de ataques y su robustez en entornos modernos

```python
from endecrypter import ChaCha20Cipher

# Crear instancia
cipher = ChaCha20Cipher()

# Generar clave
key = cipher.generate_key()  # 32 bytes

# Cifrar
mensaje = "Mensaje secreto"
encrypted, nonce = cipher.encrypt(mensaje, key)
print(encrypted)

# Descifrar
decrypted = cipher.decrypt(encrypted, key, nonce)
print(decrypted)  # "Mensaje secreto"
```

### Utilidades Binarias

El **binario** es un sistema num√©rico basado en dos d√≠gitos: 0 y 1, conocido como sistema de numeraci√≥n base 2. Cada cifra en un n√∫mero binario se llama bit (binary digit), y es la unidad m√≠nima de informaci√≥n en inform√°tica. El sistema binario es fundamental en la computaci√≥n porque los ordenadores procesan y almacenan datos en esta forma, ya que los circuitos electr√≥nicos solo pueden representar dos estados posibles: encendido (1) o apagado (0).

En el sistema binario, los n√∫meros se representan utilizando combinaciones de 0s y 1s. Por ejemplo, el n√∫mero binario 1010 representa el n√∫mero decimal 10. Cada posici√≥n en un n√∫mero binario tiene un valor que es una potencia de 2, comenzando desde la derecha con 2^0, 2^1, 2^2, y as√≠ sucesivamente. Para convertir un n√∫mero binario a decimal, se suman los valores de las posiciones donde hay un 1.

```python
from endecrypter import Binary

# Convertir texto a binario
texto = "Hello"
binario = Binary.text_to_binary(texto)
print(f"Binario: {binario}")  # 01001000 01100101 01101100 01101100 01101111

# Convertir binario a texto
texto_recuperado = Binary.binary_to_text(binario)
print(f"Texto: {texto_recuperado}")  # Hello
```

## Documentaci√≥n Detallada

### Comparativa de Cifrados

| Cifrado | Tipo | Clave | Fortaleza | Uso Recomendado |
|---------|------|-------|-----------|-----------------|
| C√©sar | Cl√°sico | N√∫mero (1-25) | Muy Baja | Educativo |
| Monoalfab√©tico | Cl√°sico | Alfabeto | Baja | Educativo |
| Polialfab√©tico | Cl√°sico | Texto | Baja-Media | Educativo |
| Transposici√≥n | Cl√°sico | N√∫mero | Baja | Educativo |
| Hill | Clasico | Matriz n * n | Baja-Media | Educativo |
| Enigma | Clasico | 3 Rotores | Media-Alta | Datos sensibles |
| DES | Moderno | 8 bytes | Media-Alta | Datos sensibles |
| RC4 | Moderno | Variable | Media | Datos sensibles |
| Binario | Util | Texto | Muy Baja | Educativo |
| 3DES | Moderno | 3 de 24 bytes | Alta | Datos comunes |
| RC5 | Moderno | 16 bytes | Media-Alta | Datos sensibles |
| RC6 | Moderno | 16 bytes | Alta | Datos sensibles |
| Salsa20 | Moderno | 32 bytes | Alta | Datos comunes | 
| ChaCha20 | Moderno | 32 bytes | Alta | Datos comunes |

## Contribuir

1. Fork el repositorio
2. Crea una rama para tu feature (`git checkout -b feature/AmazingFeature`)
3. Commit tus cambios (`git commit -m 'Add some AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abre un Pull Request

### Gu√≠a de Contribuci√≥n

- Sigue el estilo de c√≥digo existente
- A√±ade tests para nueva funcionalidad
- Actualiza la documentaci√≥n seg√∫n sea necesario
- Aseg√∫rate de que todos los tests pasen

## Licencia

Distribuido bajo la Licencia GNU. Ver `LICENSE` para m√°s informaci√≥n.
