# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError('Python 2.7 or later required')

# Import the low-level C/C++ module
if __package__ or '.' in __name__:
    from . import _temp_gvxrPython3
else:
    import _temp_gvxrPython3

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if name == "thisown":
        return self.this.own(value)
    if name == "this":
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if not static:
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if name == "thisown":
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _temp_gvxrPython3.delete_SwigPyIterator

    def value(self):
        return _temp_gvxrPython3.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _temp_gvxrPython3.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _temp_gvxrPython3.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _temp_gvxrPython3.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _temp_gvxrPython3.SwigPyIterator_equal(self, x)

    def copy(self):
        return _temp_gvxrPython3.SwigPyIterator_copy(self)

    def next(self):
        return _temp_gvxrPython3.SwigPyIterator_next(self)

    def __next__(self):
        return _temp_gvxrPython3.SwigPyIterator___next__(self)

    def previous(self):
        return _temp_gvxrPython3.SwigPyIterator_previous(self)

    def advance(self, n):
        return _temp_gvxrPython3.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _temp_gvxrPython3.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _temp_gvxrPython3.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _temp_gvxrPython3.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _temp_gvxrPython3.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _temp_gvxrPython3.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _temp_gvxrPython3.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _temp_gvxrPython3:
_temp_gvxrPython3.SwigPyIterator_swigregister(SwigPyIterator)

class Vectors(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectors_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectors___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectors___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectors___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectors___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectors___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectors___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectors___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectors___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectors___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectors_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectors_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectors_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectors_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectors_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectors_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectors_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectors_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectors_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectors_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectors_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectors_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectors_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectors_swiginit(self, _temp_gvxrPython3.new_Vectors(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectors_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectors_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectors_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectors_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectors_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectors_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectors_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectors_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectors

# Register Vectors in _temp_gvxrPython3:
_temp_gvxrPython3.Vectors_swigregister(Vectors)

class Vectori(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectori_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectori___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectori___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectori___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectori___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectori___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectori___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectori___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectori___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectori___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectori_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectori_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectori_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectori_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectori_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectori_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectori_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectori_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectori_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectori_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectori_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectori_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectori_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectori_swiginit(self, _temp_gvxrPython3.new_Vectori(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectori_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectori_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectori_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectori_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectori_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectori_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectori_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectori_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectori

# Register Vectori in _temp_gvxrPython3:
_temp_gvxrPython3.Vectori_swigregister(Vectori)

class Vectorui(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectorui_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectorui___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectorui___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectorui___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectorui___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectorui___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectorui___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectorui___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectorui___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectorui___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectorui_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectorui_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectorui_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectorui_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectorui_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectorui_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectorui_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectorui_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectorui_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectorui_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectorui_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectorui_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectorui_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectorui_swiginit(self, _temp_gvxrPython3.new_Vectorui(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectorui_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectorui_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectorui_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectorui_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectorui_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectorui_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectorui_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectorui_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectorui

# Register Vectorui in _temp_gvxrPython3:
_temp_gvxrPython3.Vectorui_swigregister(Vectorui)

class Vectorss(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectorss_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectorss___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectorss___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectorss___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectorss___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectorss___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectorss___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectorss___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectorss___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectorss___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectorss_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectorss_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectorss_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectorss_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectorss_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectorss_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectorss_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectorss_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectorss_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectorss_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectorss_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectorss_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectorss_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectorss_swiginit(self, _temp_gvxrPython3.new_Vectorss(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectorss_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectorss_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectorss_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectorss_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectorss_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectorss_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectorss_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectorss_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectorss

# Register Vectorss in _temp_gvxrPython3:
_temp_gvxrPython3.Vectorss_swigregister(Vectorss)

class Vectorf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectorf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectorf___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectorf___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectorf___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectorf___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectorf___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectorf___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectorf___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectorf___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectorf___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectorf_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectorf_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectorf_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectorf_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectorf_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectorf_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectorf_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectorf_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectorf_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectorf_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectorf_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectorf_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectorf_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectorf_swiginit(self, _temp_gvxrPython3.new_Vectorf(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectorf_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectorf_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectorf_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectorf_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectorf_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectorf_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectorf_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectorf_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectorf

# Register Vectorf in _temp_gvxrPython3:
_temp_gvxrPython3.Vectorf_swigregister(Vectorf)

class Vectord(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectord___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectord___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectord___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectord___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectord___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectord___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectord___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectord___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectord___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectord_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectord_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectord_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectord_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectord_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectord_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectord_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectord_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectord_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectord_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectord_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectord_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectord_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectord_swiginit(self, _temp_gvxrPython3.new_Vectord(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectord_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectord_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectord_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectord_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectord_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectord_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectord_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectord_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectord

# Register Vectord in _temp_gvxrPython3:
_temp_gvxrPython3.Vectord_swigregister(Vectord)

class Vectorff(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectorff_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectorff___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectorff___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectorff___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectorff___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectorff___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectorff___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectorff___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectorff___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectorff___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectorff_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectorff_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectorff_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectorff_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectorff_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectorff_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectorff_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectorff_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectorff_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectorff_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectorff_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectorff_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectorff_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectorff_swiginit(self, _temp_gvxrPython3.new_Vectorff(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectorff_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectorff_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectorff_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectorff_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectorff_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectorff_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectorff_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectorff_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectorff

# Register Vectorff in _temp_gvxrPython3:
_temp_gvxrPython3.Vectorff_swigregister(Vectorff)

class Vectordd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectordd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectordd___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectordd___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectordd___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectordd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectordd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectordd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectordd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectordd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectordd___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectordd_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectordd_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectordd_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectordd_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectordd_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectordd_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectordd_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectordd_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectordd_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectordd_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectordd_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectordd_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectordd_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectordd_swiginit(self, _temp_gvxrPython3.new_Vectordd(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectordd_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectordd_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectordd_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectordd_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectordd_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectordd_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectordd_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectordd_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectordd

# Register Vectordd in _temp_gvxrPython3:
_temp_gvxrPython3.Vectordd_swigregister(Vectordd)

class Vectorfff(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectorfff_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectorfff___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectorfff___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectorfff___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectorfff___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectorfff___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectorfff___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectorfff___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectorfff___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectorfff___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectorfff_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectorfff_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectorfff_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectorfff_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectorfff_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectorfff_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectorfff_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectorfff_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectorfff_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectorfff_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectorfff_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectorfff_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectorfff_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectorfff_swiginit(self, _temp_gvxrPython3.new_Vectorfff(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectorfff_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectorfff_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectorfff_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectorfff_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectorfff_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectorfff_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectorfff_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectorfff_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectorfff

# Register Vectorfff in _temp_gvxrPython3:
_temp_gvxrPython3.Vectorfff_swigregister(Vectorfff)

class Vectorddd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectorddd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectorddd___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectorddd___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectorddd___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectorddd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectorddd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectorddd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectorddd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectorddd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectorddd___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectorddd_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectorddd_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectorddd_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectorddd_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectorddd_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectorddd_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectorddd_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectorddd_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectorddd_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectorddd_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectorddd_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectorddd_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectorddd_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectorddd_swiginit(self, _temp_gvxrPython3.new_Vectorddd(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectorddd_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectorddd_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectorddd_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectorddd_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectorddd_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectorddd_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectorddd_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectorddd_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectorddd

# Register Vectorddd in _temp_gvxrPython3:
_temp_gvxrPython3.Vectorddd_swigregister(Vectorddd)

class Vectorpdd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectorpdd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectorpdd___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectorpdd___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectorpdd___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectorpdd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectorpdd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectorpdd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectorpdd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectorpdd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectorpdd___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectorpdd_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectorpdd_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectorpdd_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectorpdd_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectorpdd_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectorpdd_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectorpdd_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectorpdd_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectorpdd_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectorpdd_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectorpdd_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectorpdd_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectorpdd_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectorpdd_swiginit(self, _temp_gvxrPython3.new_Vectorpdd(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectorpdd_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectorpdd_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectorpdd_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectorpdd_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectorpdd_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectorpdd_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectorpdd_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectorpdd_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectorpdd

# Register Vectorpdd in _temp_gvxrPython3:
_temp_gvxrPython3.Vectorpdd_swigregister(Vectorpdd)

class Vectorpff(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectorpff_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectorpff___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectorpff___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectorpff___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectorpff___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectorpff___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectorpff___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectorpff___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectorpff___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectorpff___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectorpff_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectorpff_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectorpff_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectorpff_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectorpff_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectorpff_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectorpff_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectorpff_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectorpff_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectorpff_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectorpff_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectorpff_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectorpff_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectorpff_swiginit(self, _temp_gvxrPython3.new_Vectorpff(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectorpff_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectorpff_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectorpff_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectorpff_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectorpff_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectorpff_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectorpff_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectorpff_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectorpff

# Register Vectorpff in _temp_gvxrPython3:
_temp_gvxrPython3.Vectorpff_swigregister(Vectorpff)

class Vectorpuif(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _temp_gvxrPython3.Vectorpuif_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _temp_gvxrPython3.Vectorpuif___nonzero__(self)

    def __bool__(self):
        return _temp_gvxrPython3.Vectorpuif___bool__(self)

    def __len__(self):
        return _temp_gvxrPython3.Vectorpuif___len__(self)

    def __getslice__(self, i, j):
        return _temp_gvxrPython3.Vectorpuif___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _temp_gvxrPython3.Vectorpuif___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _temp_gvxrPython3.Vectorpuif___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _temp_gvxrPython3.Vectorpuif___delitem__(self, *args)

    def __getitem__(self, *args):
        return _temp_gvxrPython3.Vectorpuif___getitem__(self, *args)

    def __setitem__(self, *args):
        return _temp_gvxrPython3.Vectorpuif___setitem__(self, *args)

    def pop(self):
        return _temp_gvxrPython3.Vectorpuif_pop(self)

    def append(self, x):
        return _temp_gvxrPython3.Vectorpuif_append(self, x)

    def empty(self):
        return _temp_gvxrPython3.Vectorpuif_empty(self)

    def size(self):
        return _temp_gvxrPython3.Vectorpuif_size(self)

    def swap(self, v):
        return _temp_gvxrPython3.Vectorpuif_swap(self, v)

    def begin(self):
        return _temp_gvxrPython3.Vectorpuif_begin(self)

    def end(self):
        return _temp_gvxrPython3.Vectorpuif_end(self)

    def rbegin(self):
        return _temp_gvxrPython3.Vectorpuif_rbegin(self)

    def rend(self):
        return _temp_gvxrPython3.Vectorpuif_rend(self)

    def clear(self):
        return _temp_gvxrPython3.Vectorpuif_clear(self)

    def get_allocator(self):
        return _temp_gvxrPython3.Vectorpuif_get_allocator(self)

    def pop_back(self):
        return _temp_gvxrPython3.Vectorpuif_pop_back(self)

    def erase(self, *args):
        return _temp_gvxrPython3.Vectorpuif_erase(self, *args)

    def __init__(self, *args):
        _temp_gvxrPython3.Vectorpuif_swiginit(self, _temp_gvxrPython3.new_Vectorpuif(*args))

    def push_back(self, x):
        return _temp_gvxrPython3.Vectorpuif_push_back(self, x)

    def front(self):
        return _temp_gvxrPython3.Vectorpuif_front(self)

    def back(self):
        return _temp_gvxrPython3.Vectorpuif_back(self)

    def assign(self, n, x):
        return _temp_gvxrPython3.Vectorpuif_assign(self, n, x)

    def resize(self, *args):
        return _temp_gvxrPython3.Vectorpuif_resize(self, *args)

    def insert(self, *args):
        return _temp_gvxrPython3.Vectorpuif_insert(self, *args)

    def reserve(self, n):
        return _temp_gvxrPython3.Vectorpuif_reserve(self, n)

    def capacity(self):
        return _temp_gvxrPython3.Vectorpuif_capacity(self)
    __swig_destroy__ = _temp_gvxrPython3.delete_Vectorpuif

# Register Vectorpuif in _temp_gvxrPython3:
_temp_gvxrPython3.Vectorpuif_swigregister(Vectorpuif)


def getMajorVersionOfCoreGVXR():
    r"""


    Accessor on the major version of the core gVirtualXRay library (gvxr). This
    number is changed when incompatible API changes have been made.  

    Returns
    -------
    the major version number  

    """
    return _temp_gvxrPython3.getMajorVersionOfCoreGVXR()

def getMinorVersionOfCoreGVXR():
    r"""


    Accessor on the minor version of the core gVirtualXRay library (gvxr). This
    number is changed when new functionalities have been added in a backwards-
    compatible manner.  

    Returns
    -------
    the minor version number  

    """
    return _temp_gvxrPython3.getMinorVersionOfCoreGVXR()

def getPatchVersionOfCoreGVXR():
    r"""


    Accessor on the minor version of the core gVirtualXRay library (gvxr). This
    number is changed when bug fixes have been added in a backwards-compatible
    manner.  

    Returns
    -------
    the patch version number  

    """
    return _temp_gvxrPython3.getPatchVersionOfCoreGVXR()

def getVersionOfCoreGVXR():
    r"""


    Accessor on the full string version of the core gVirtualXRay library (gvxr).  

    Returns
    -------
    the full version number  

    """
    return _temp_gvxrPython3.getVersionOfCoreGVXR()

def getMajorVersionOfSimpleGVXR():
    r"""


    Accessor on the major version of SimpleGVXR. This number is changed when
    incompatible API changes have been made.  

    Returns
    -------
    the major version number  

    """
    return _temp_gvxrPython3.getMajorVersionOfSimpleGVXR()

def getMinorVersionOfSimpleGVXR():
    r"""


    Accessor on the minor version of SimpleGVXR. This number is changed when new
    functionalities have been added in a backwards-compatible manner.  

    Returns
    -------
    the minor version number  

    """
    return _temp_gvxrPython3.getMinorVersionOfSimpleGVXR()

def getPatchVersionOfSimpleGVXR():
    r"""


    Accessor on the minor version of SimpleGVXR. This number is changed when bug
    fixes have been added in a backwards-compatible manner.  

    Returns
    -------
    the patch version number  

    """
    return _temp_gvxrPython3.getPatchVersionOfSimpleGVXR()

def getVersionOfSimpleGVXR():
    r"""


    Accessor on the full string version of SimpleGVXR.  

    Returns
    -------
    the full version number  

    """
    return _temp_gvxrPython3.getVersionOfSimpleGVXR()

def getOpenGlRenderer():
    r"""


    Accessor on the OpenGL renderer.  

    Returns
    -------
    a string displaying the OpenGL renderer  

    """
    return _temp_gvxrPython3.getOpenGlRenderer()

def getOpenGlVersion():
    r"""


    Accessor on the OpenGL version.  

    Returns
    -------
    a string displaying the OpenGL version  

    """
    return _temp_gvxrPython3.getOpenGlVersion()

def getOpenGlVendor():
    r"""


    Accessor on the OpenGL vendor.  

    Returns
    -------
    a string displaying the OpenGL vendor  

    """
    return _temp_gvxrPython3.getOpenGlVendor()

def getNoiseGenerator():
    r"""


    Accessor on the Poisson noise implementation.  

    Returns
    -------
    a string displaying the Poisson noise implementation, e.g. C++ standard library
    or GSL, with or without OpenMP.  

    """
    return _temp_gvxrPython3.getNoiseGenerator()

def getBuildEnvironment():
    r"""


    Print out all the build environment variables.  

    Returns
    -------
    a string all the build environment variables.  

    """
    return _temp_gvxrPython3.getBuildEnvironment()

def useLogFile(*args):
    r"""


    Turn on/off the use of a log file.  

    Parameters
    ----------
    * `aFileName` :  
        the name of the file in which the output will be saved. If it is equal to 0,
        NULL, or nullptr, the standard output, will be used (default value:
        "gvxr.log")  

    """
    return _temp_gvxrPython3.useLogFile(*args)

def setSeed(aRandomGeneratorSeed):
    r"""


    Set the seed of the random number generator.  

    Parameters
    ----------
    * `aRandomGeneratorSeed` :  
        the seed  

    """
    return _temp_gvxrPython3.setSeed(aRandomGeneratorSeed)

def autoCreateOpenGLContext(aFlag=True):
    r"""


    Create an OpenGL context automatically.  

    Parameters
    ----------
    * `aFlag` :  
        true to create the OpenGL context automatically, false otherwise (default
        value: true)  

    """
    return _temp_gvxrPython3.autoCreateOpenGLContext(aFlag)

def getIdentityMatrix4():
    r"""


    Return a 4x4 identity matrix.  

    Returns
    -------
    a 4x4 identity matrix  

    """
    return _temp_gvxrPython3.getIdentityMatrix4()

def displayNode(aLabel):
    r"""


    Display the scenegraph node using OpenGL.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    """
    return _temp_gvxrPython3.displayNode(aLabel)

def moveToCenter(*args):
    r"""


    Move a polygon mesh to the centre.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh in the scenegraph  

    """
    return _temp_gvxrPython3.moveToCenter(*args)

def moveToCentre(*args):
    r"""


    Move a polygon mesh to the centre.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh in the scenegraph  

    """
    return _temp_gvxrPython3.moveToCentre(*args)

def scaleNode(aLabel, x, y, z):
    r"""


    Scale a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh to transform  
    * `x` :  
        the scaling factor along the X-axis  
    * `y` :  
        the scaling factor along the Y-axis  
    * `z` :  
        the scaling factor along the Z-axis  

    """
    return _temp_gvxrPython3.scaleNode(aLabel, x, y, z)

def rotateNode(*args):
    r"""


    Rotate a polygon mesh using the yaw, pitch, roll method.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh to transform  
    * `yaw` :  
        a counterclockwise rotation of yaw degrees about the z-axis  
    * `pitch` :  
        a counterclockwise rotation of yaw degrees about the y-axis  
    * `roll` :  
        a counterclockwise rotation of yaw degrees about the x-axis  

    """
    return _temp_gvxrPython3.rotateNode(*args)

def translateNode(aLabel, x, y, z, aUnitOfLength):
    r"""


    Translate a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh to transform  
    * `x` :  
        the component of the translation vector along the X-axis  
    * `y` :  
        the component of the translation vector along the Y-axis  
    * `z` :  
        the component of the translation vector along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the x, y and z parameters. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.translateNode(aLabel, x, y, z, aUnitOfLength)

def shearNode(aLabel, yx, zx, xy, zy, xz, yz):
    r"""


    Use a shear matrix to transform the node.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh to transform  
    * `yx` :  
        the yx component of the shear matrix  
    * `zx` :  
        the zx component of the shear matrix  
    * `xy` :  
        the xy component of the shear matrix  
    * `zy` :  
        the zy component of the shear matrix  
    * `xz` :  
        the xz component of the shear matrix  
    * `yz` :  
        the yz component of the shear matrix  

    """
    return _temp_gvxrPython3.shearNode(aLabel, yx, zx, xy, zy, xz, yz)

def resetSceneTransformation():
    r"""


    Replace the 3-D transformation matrix of the overall 3-D scene by an identity
    matrix.  

    """
    return _temp_gvxrPython3.resetSceneTransformation()

def scaleScene(*args):
    r"""


    Scale the 3-D scene (all the polygon meshes will be affected but not modified).  

    Parameters
    ----------
    * `x` :  
        the scaling factor along the X-axis  
    * `y` :  
        the scaling factor along the Y-axis  
    * `z` :  
        the scaling factor along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the x, y and z parameters. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.scaleScene(*args)

def rotateScene(*args):
    r"""


    Rotate the 3-D scene using the yaw, pitch, roll method (all the polygon meshes
    will be affected but not modified).  

    Parameters
    ----------
    * `yaw` :  
        a counterclockwise rotation of yaw degrees about the z-axis  
    * `pitch` :  
        a counterclockwise rotation of yaw degrees about the y-axis  
    * `roll` :  
        a counterclockwise rotation of yaw degrees about the x-axis  

    """
    return _temp_gvxrPython3.rotateScene(*args)

def translateScene(x, y, z, aUnitOfLength):
    r"""


    Translate the 3-D scene (all the polygon meshes will be affected but not
    modified).  

    Parameters
    ----------
    * `x` :  
        the component of the translation vector along the X-axis  
    * `y` :  
        the component of the translation vector along the Y-axis  
    * `z` :  
        the component of the translation vector along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the x, y and z parameters. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.translateScene(x, y, z, aUnitOfLength)

def getSceneTransformationMatrix():
    r"""


    Accessor on the 3-D scene transformation matrix.  

    Returns
    -------
    the 3-D scene transformation matrix as a 4x4 array  

    """
    return _temp_gvxrPython3.getSceneTransformationMatrix()

def getRootTransformationMatrix():
    r"""


    Accessor on the transformation matrix of the scengraph's root node.  

    Returns
    -------
    the scengraph's root node transformation matrix as a 4x4 array  

    """
    return _temp_gvxrPython3.getRootTransformationMatrix()

def getNodeLocalTransformationMatrix(aLabel):
    r"""


    Accessor on the transformation matrix of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    the scengraph's root node transformation matrix as a 4x4 array  

    """
    return _temp_gvxrPython3.getNodeLocalTransformationMatrix(aLabel)

def getNodeWorldTransformationMatrix(aLabel):
    r"""


    Accessor on the transformation matrix of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    the scengraph's root node transformation matrix as a 4x4 array  

    """
    return _temp_gvxrPython3.getNodeWorldTransformationMatrix(aLabel)

def setSceneTransformationMatrix(aMatrix):
    r"""


    Set the 3-D scene transformation matrix.  

    Parameters
    ----------
    * `aMatrix` :  
        the transformation matrix as a 4x4 array  

    """
    return _temp_gvxrPython3.setSceneTransformationMatrix(aMatrix)

def setRootTransformationMatrix(aMatrix):
    r"""


    Set the transformation matrix of the scengraph's root node.  

    Parameters
    ----------
    * `aMatrix` :  
        the transformation matrix as a 4x4 array  

    """
    return _temp_gvxrPython3.setRootTransformationMatrix(aMatrix)

def setNodeTransformationMatrix(aLabel, aMatrix):
    r"""


    Set the transformation matrix of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aMatrix` :  
        the transformation matrix as a 4x4 array  

    """
    return _temp_gvxrPython3.setNodeTransformationMatrix(aLabel, aMatrix)

def setHU(aLabel, HU):
    r"""


    Set the Hounsfield value corresponding to the material properties of a polygon
    mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `HU` :  
        the Hounsfield value  

    """
    return _temp_gvxrPython3.setHU(aLabel, HU)

def setHounsfieldUnit(aLabel, HU):
    r"""


    Set the Hounsfield value corresponding to the material properties of a polygon
    mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `HU` :  
        the Hounsfield value  

    """
    return _temp_gvxrPython3.setHounsfieldUnit(aLabel, HU)

def setHounsfieldValue(aLabel, HU):
    r"""


    Set the Hounsfield value corresponding to the material properties of a polygon
    mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `HU` :  
        the Hounsfield value  

    """
    return _temp_gvxrPython3.setHounsfieldValue(aLabel, HU)

def setElement(*args):
    r"""


    Set the chemical element (or element) corresponding to the material properties
    of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aName` :  
        the symbol or name corresponding to the element  

    """
    return _temp_gvxrPython3.setElement(*args)

def setMixture(*args):
    r"""


    Set the mixture corresponding to the material properties of a polygon mesh.
    Don't forget to set the density of the material.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aSymbolSet` :  
        the array of element symbols  
    * `aWeightSet` :  
        the corresponding weights  

    """
    return _temp_gvxrPython3.setMixture(*args)

def setCompound(aLabel, aCompound):
    r"""


    Set the compound corresponding to the material properties of a polygon mesh.
    Don't forget to set the density of the material.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aCompound` :  
        the details about the compound. It is given as a sequence of element symbol
        & number of atoms, e.g. H2O for water and SiC for silicon carbide.  

    """
    return _temp_gvxrPython3.setCompound(aLabel, aCompound)

def setMassAttenuationCoefficient(aLabel, aCoefficient, aUnit):
    r"""


    Set the mass attenuation coefficient corresponding to the material properties of
    a polygon mesh. Don't forget to set the density of the material.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aCoefficient` :  
        the mass attenuation coefficient  
    * `aUnit` :  
        the unit corresponding to aCoefficient. Acceptable values are: "cm2/g" and
        "cm2.g-1"  

    """
    return _temp_gvxrPython3.setMassAttenuationCoefficient(aLabel, aCoefficient, aUnit)

def setLinearAttenuationCoefficient(aLabel, aCoefficient, aUnit):
    r"""


    Set the linear attenuation coefficient corresponding to the material properties
    of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aCoefficient` :  
        the liner attenuation coefficient  
    * `aUnit` :  
        the unit corresponding to aCoefficient. Acceptable values are: "cm-1"  

    """
    return _temp_gvxrPython3.setLinearAttenuationCoefficient(aLabel, aCoefficient, aUnit)

def setMu(aLabel, aCoefficient, aUnit):
    r"""


    Set the linear attenuation coefficient corresponding to the material properties
    of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aCoefficient` :  
        the liner attenuation coefficient  
    * `aUnit` :  
        the unit corresponding to aCoefficient. Acceptable values are: "cm-1"  

    """
    return _temp_gvxrPython3.setMu(aLabel, aCoefficient, aUnit)

def setDensity(aLabel, aDensity, aUnit):
    r"""


    Set the density corresponding to the material properties of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aDensity` :  
        the density  
    * `aUnit` :  
        the unit corresponding to aDensity. Acceptable values are: "g/cm3",
        "g.cm-3", "mg/cm3", "mg.cm-3", "kg/m3", and "kg.m-3".  

    """
    return _temp_gvxrPython3.setDensity(aLabel, aDensity, aUnit)

def getDensity(aLabel):
    r"""


    Accessor on the density corresponding to the material properties of a polygon
    mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    the density of the polygon mesh's material in g/cm3  

    """
    return _temp_gvxrPython3.getDensity(aLabel)

def getMassAttenuationCoefficient(aLabel, anEnergy, aUnitOfEnergy):
    r"""


    Accessor on the mass attenuation coefficient at a given energy corresponding to
    the material properties of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the mass attenuation coefficient of the polygon mesh's material in cm2/g  

    """
    return _temp_gvxrPython3.getMassAttenuationCoefficient(aLabel, anEnergy, aUnitOfEnergy)

def getLinearAttenuationCoefficient(aLabel, anEnergy, aUnitOfEnergy):
    r"""


    Accessor on the linear attenuation coefficient at a given energy corresponding
    to the material properties of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the linear attenuation coefficient of the polygon mesh's material in cm-1  

    """
    return _temp_gvxrPython3.getLinearAttenuationCoefficient(aLabel, anEnergy, aUnitOfEnergy)

def getMaterialLabel(aLabel):
    r"""


    Accessor on the material label of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    the label of the material  

    """
    return _temp_gvxrPython3.getMaterialLabel(aLabel)

def getCompound(aLabel):
    r"""


    Accessor on the compound description of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    if the sample is made of a compound, then return the description of the compound
    (e.g. H2O for water), otherwise return an empty string  

    """
    return _temp_gvxrPython3.getCompound(aLabel)

def getMixtureElementSet(aLabel):
    r"""


    Accessor on the element Z number set of the mixture of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    if the sample is made of a mixture, then return the element Z number set of the
    mixture, otherwise return an empty vector  

    """
    return _temp_gvxrPython3.getMixtureElementSet(aLabel)

def getMixtureWeightSet(aLabel):
    r"""


    Accessor on the element weight set of the mixture of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    if the sample is made of a mixture, then return the element weight set of the
    mixture, otherwise return an empty vector  

    """
    return _temp_gvxrPython3.getMixtureWeightSet(aLabel)

def displayScene(aSceneRotationFlag=True, aWindowID=-1):
    r"""


    3-D visualisation of the 3-D scene (source, detector, and scanned objects). Note
    that there is no interactive loop running.  

    Parameters
    ----------
    * `aSceneRotationFlag` :  
        true if the 3-D scene has to be rotated with the arc-ball method, false
        otherwise (default value: true)  
    * `aWindowID` :  
        the numerical ID of the corresponding context (default value: -1, means that
        the active context will be used)  

    """
    return _temp_gvxrPython3.displayScene(aSceneRotationFlag, aWindowID)

def renderLoop(aWindowID=-1):
    r"""


    3-D visualisation of the 3-D scene (source, detector, and scanned objects). Note
    that there is interactive loop running. Keys are:  

    *   Q/Escape: to quit the event loop (does not close the window)  
    *   B: display/hide the X-ray beam  
    *   W: display the polygon meshes in solid or wireframe  
    *   N: display the X-ray image in negative or positive  
    *   L: switch lighting on/off  
    *   D: display/hide the X-ray detector  
    *   V: display/hide normal vectors  

        Parameters:  
        * `aWindowID` :  
            the numerical ID of the corresponding context (default value: -1, means
            that the active context will be used)  

    """
    return _temp_gvxrPython3.renderLoop(aWindowID)

def startArcBallRotation(x, y):
    r"""


    Call this function when the user starts an arc-ball rotation (e.g. left-mouse
    button click in the 3-D visualisation window).  

    Parameters
    ----------
    * `x` :  
        the cursor x-axis position in the viewport coordinate system  
    * `y` :  
        the cursor y-axis position in the viewport coordinate system  

    """
    return _temp_gvxrPython3.startArcBallRotation(x, y)

def stopArcBallRotation():
    r"""


    Call this function when the user stops an arc-ball rotation (e.g. release the
    left-mouse button click in the 3-D visualisation window).  

    """
    return _temp_gvxrPython3.stopArcBallRotation()

def usingArcBallRotation():
    r"""


    Check if arc-ball rotation is currently in use.  

    Returns
    -------
    true if arc-ball rotation is currently in use, false otherwise  

    """
    return _temp_gvxrPython3.usingArcBallRotation()

def cursorPositionCallback(x, y, aViewportWidth, aViewportHeight):
    r"""


    Call this function when the user moves the mouse.  

    Parameters
    ----------
    * `x` :  
        the cursor x-axis position in the viewport coordinate system  
    * `y` :  
        the cursor y-axis position in the viewport coordinate system  
    * `aViewportWidth` :  
        the size of the viewport along the x-axis  
    * `aViewportHeight` :  
        the size of the viewport along the y-axis  

    """
    return _temp_gvxrPython3.cursorPositionCallback(x, y, aViewportWidth, aViewportHeight)

def scrollCallback(xoffset, yoffset):
    r"""


    Call this function when the user scrolls.  

    Parameters
    ----------
    * `xoffset` :  
        the scroll offset along the x-axis (not used)  
    * `yoffset` :  
        the scroll offset along the y-axis (used for zooming in and out)  

    """
    return _temp_gvxrPython3.scrollCallback(xoffset, yoffset)

def setZoom(aZoomValue):
    r"""


    Set the zoom value used in the 3D visualisation.  

    Parameters
    ----------
    * `aZoomValue` :  
        the zoom value  

    """
    return _temp_gvxrPython3.setZoom(aZoomValue)

def getZoom():
    r"""


    Accessor on the zoom value used in the 3D visualisation.  

    Returns
    -------
    the zoom value  

    """
    return _temp_gvxrPython3.getZoom()

def setSceneRotationMatrix(aRotationMatrix):
    r"""


    Set the transformation matrix used in the 3D visualisation.  

    Parameters
    ----------
    * `aRotationMatrix` :  
        the transformation matrix  

    """
    return _temp_gvxrPython3.setSceneRotationMatrix(aRotationMatrix)

def getSceneRotationMatrix():
    r"""


    Accessor on the transformation matrix used in the 3D visualisation.  

    Returns
    -------
    the transformation matrix  

    """
    return _temp_gvxrPython3.getSceneRotationMatrix()

def showWindow(aWindowID=-1):
    r"""


    Make an OpenGL context visible and display a window.  

    Parameters
    ----------
    * `aWindowID` :  
        the numerical ID of the corresponding context (default value: -1, means that
        the active context will be used)  

    """
    return _temp_gvxrPython3.showWindow(aWindowID)

def hideWindow(aWindowID=-1):
    r"""


    Hide a window.  

    Parameters
    ----------
    * `aWindowID` :  
        the numerical ID of the corresponding context (default value: -1, means that
        the active context will be used)  

    """
    return _temp_gvxrPython3.hideWindow(aWindowID)

def setWindowPosition(aPositionX, aPositionY, aWindowID=-1):
    r"""


    Move a window.  

    Parameters
    ----------
    * `aPositionX` :  
        the window position along the X axis of the screen  
    * `aPositionY` :  
        the window position along the Y axis of the screen  
    * `aWindowID` :  
        the numerical ID of the corresponding context (default value: -1, means that
        the active context will be used)  

    """
    return _temp_gvxrPython3.setWindowPosition(aPositionX, aPositionY, aWindowID)

def setWindowBackGroundColour(R, G, B, aWindowID=-1):
    r"""


    Set window background colour.  

    Parameters
    ----------
    * `R` :  
        the red colour [0, 1]  
    * `G` :  
        the green colour [0, 1]  
    * `B` :  
        the blue colour [0, 1]  
    * `aWindowID` :  
        the numerical ID of the corresponding context (default value: -1, means that
        the active context will be used)  

    """
    return _temp_gvxrPython3.setWindowBackGroundColour(R, G, B, aWindowID)

def setWindowBackGroundColor(R, G, B, aWindowID=-1):
    r"""


    Set window background colour.  

    Parameters
    ----------
    * `R` :  
        the red colour [0, 1]  
    * `G` :  
        the green colour [0, 1]  
    * `B` :  
        the blue colour [0, 1]  
    * `aWindowID` :  
        the numerical ID of the corresponding context (default value: -1, means that
        the active context will be used)  

    """
    return _temp_gvxrPython3.setWindowBackGroundColor(R, G, B, aWindowID)

def takeScreenshot(aWindowID=-1):
    r"""


    Take screenshot.  

    Parameters
    ----------
    * `aWindowID` :  
        the numerical ID of the corresponding context (default value: -1, means that
        the active context will be used)  

    Returns
    -------
    the 2D image in RGB  

    """
    return _temp_gvxrPython3.takeScreenshot(aWindowID)

def getLatestScreenshot():
    r"""


    Get the latest screenshot.  

    Returns
    -------
    the 2D image in RGB  

    """
    return _temp_gvxrPython3.getLatestScreenshot()

def getWhiteImage(anIntegrateEnergyFlag=True):
    r"""


    Get a flat field image that can be used in the flat-field correction (FFC). Note
    that if Poisson noise is used, the function will return a different image each
    time the function is called.  

    Parameters
    ----------
    * `anIntegrateEnergyFlag` :  
        if true the energy fluence is returned, otherwise the number of photons is
        returned (default value: true)  

    Returns
    -------
    the 2D image in greyscale values  

    """
    return _temp_gvxrPython3.getWhiteImage(anIntegrateEnergyFlag)

def getWhiteSpectralImage():
    r"""


    Get a set of flat field images that can be used in the flat-field correction
    (FFC). When a spectral detector is used, a 2D image is generated for each energy
    band. Note that if Poisson noise is used, the function will return a different
    set each time the function is called.  

    Returns
    -------
    the set of 2D images in greyscale values  

    """
    return _temp_gvxrPython3.getWhiteSpectralImage()

def saveSTLfile(*args):
    r"""


    Save the polygon mesh of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aFileName` :  
        the name of the output file (default: means that the filename will be
        automatically generated and the file saved in the current path)  

    """
    return _temp_gvxrPython3.saveSTLfile(*args)

def getMaxRadiusLbufferArtefactFilter():
    r"""


    Accessor on the max radius of the L-buffer artefact correction filter.  

    Returns
    -------
    the radius in number of pixels  

    """
    return _temp_gvxrPython3.getMaxRadiusLbufferArtefactFilter()

def setMaxRadiusLbufferArtefactFilter(aRadius):
    r"""


    Set the max radius of the L-buffer artefact correction filter.  

    Parameters
    ----------
    * `aRadius` :  
        the radius in number of pixels  

    """
    return _temp_gvxrPython3.setMaxRadiusLbufferArtefactFilter(aRadius)

def isArtefactFilteringOnGPUEnabled():
    r"""


    Check whether the GPU implementation of the L-buffer artefact correction filter
    is enabled.  

    Returns
    -------
    true if the filter is active, otherwise return false  

    """
    return _temp_gvxrPython3.isArtefactFilteringOnGPUEnabled()

def isArtefactFilteringOnCPUEnabled():
    r"""


    Check whether the CPU implementation of the L-buffer artefact correction filter
    is enabled.  

    Returns
    -------
    true if the filter is active, otherwise return false  

    """
    return _temp_gvxrPython3.isArtefactFilteringOnCPUEnabled()

def getImageWidth(anImage):
    r"""


    Accessor on the width of a given image.  

    Parameters
    ----------
    * `anImage` :  
        the image  

    Returns
    -------
    the width of the image (in number of pixels)  

    """
    return _temp_gvxrPython3.getImageWidth(anImage)

def getImageHeght(anImage):
    r"""


    Accessor on the height of a given image.  

    Parameters
    ----------
    * `anImage` :  
        the image  

    Returns
    -------
    the height of the image (in number of pixels)  

    """
    return _temp_gvxrPython3.getImageHeght(anImage)

def getImageRow(anImage, j):
    r"""


    Accessor on the j-th row of pixels of a given image.  

    Parameters
    ----------
    * `anImage` :  
        the image  
    * `j` :  
        the row number  

    Returns
    -------
    the j-th row of pixels  

    """
    return _temp_gvxrPython3.getImageRow(anImage, j)

def getElementName(*args):
    r"""


    Accessor on the chemical element's name depending on its symbol.  

    Parameters
    ----------
    * `aSymbol` :  
        the symbol of the element  

    Returns
    -------
    the name of the corresponding element  

    """
    return _temp_gvxrPython3.getElementName(*args)

def getElementSymbol(Z):
    r"""


    Accessor on the chemical element' symbol depending on its Z number.  

    Parameters
    ----------
    * `Z` :  
        the atomic number of the element  

    Returns
    -------
    the name of the corresponding element  

    """
    return _temp_gvxrPython3.getElementSymbol(Z)

def getElementAtomicNumber(anElement):
    r"""


    Accessor on the chemical element's Z number.  

    Parameters
    ----------
    * `anElement` :  
        the name or symbol of the element  

    Returns
    -------
    the Z number of the corresponding element  

    """
    return _temp_gvxrPython3.getElementAtomicNumber(anElement)

def getDensityFromElement(*args):
    r"""


    Accessor on the chemical element's density.  

    Parameters
    ----------
    * `Z` :  
        the Z number of the element  

    Returns
    -------
    the density of the corresponding element (in g / cm3)  

    """
    return _temp_gvxrPython3.getDensityFromElement(*args)

def getDensityFromHU(HU):
    r"""


    Accessor on the HU's density.  

    Parameters
    ----------
    * `HU` :  
        the HU  

    Returns
    -------
    the density of the corresponding HU (in g / cm3)  

    """
    return _temp_gvxrPython3.getDensityFromHU(HU)

def getMassAttenuationFromElement(*args):
    r"""


    Accessor on the chemical element's mass attenuation.  

    Parameters
    ----------
    * `Z` :  
        the Z number of the element  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the mass attenuation of the corresponding element (in cm2/g)  

    """
    return _temp_gvxrPython3.getMassAttenuationFromElement(*args)

def getMassAttenuationFromHU(HU, anEnergy, aUnitOfEnergy):
    r"""


    Accessor on the HU's mass attenuation.  

    Parameters
    ----------
    * `HU` :  
        the HU  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the density of the corresponding HU (in cm2/g)  

    """
    return _temp_gvxrPython3.getMassAttenuationFromHU(HU, anEnergy, aUnitOfEnergy)

def getMassAttenuationFromMixture(aMixture, anEnergy, aUnitOfEnergy):
    r"""


    Accessor on the mixture's mass attenuation.  

    Parameters
    ----------
    * `aMixture` :  
        the details about the mixture. It is given as a sequence of element symbol &
        relative weight, e.g. Ti90Al6V4.  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the mass attenuation of the corresponding mixture (in cm2/g)  

    """
    return _temp_gvxrPython3.getMassAttenuationFromMixture(aMixture, anEnergy, aUnitOfEnergy)

def getMassAttenuationFromCompound(aCompound, anEnergy, aUnitOfEnergy):
    r"""


    Accessor on the compound's mass attenuation.  

    Parameters
    ----------
    * `aCompound` :  
        the details about the compound. It is given as a sequence of element symbol
        & number of atoms, e.g. H2O for water and SiC for silicon carbide.  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the mass attenuation of the corresponding compound (in cm2/g)  

    """
    return _temp_gvxrPython3.getMassAttenuationFromCompound(aCompound, anEnergy, aUnitOfEnergy)

def getMuFromHU(HU, anEnergy, aUnitOfEnergy):
    r"""


    Accessor on the HU's linear attenuation coefficient.  

    Parameters
    ----------
    * `HU` :  
        the HU  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the linear attenuation coefficient (in cm-1)  

    """
    return _temp_gvxrPython3.getMuFromHU(HU, anEnergy, aUnitOfEnergy)

def convertHU2mu(anImage, anEnergy, aUnitOfEnergy):
    r"""


    Convert a 3D volume in HU values into linear attenuation coefficients.  

    Parameters
    ----------
    * `anImage` :  
        the 3D volume in HU values  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the 3D volume in linear attenuation coefficients (cm^-1)  

    """
    return _temp_gvxrPython3.convertHU2mu(anImage, anEnergy, aUnitOfEnergy)

def rayIntersect(aLabel, aRayOriginX, aRayOriginY, aRayOriginZ, aRayDirectionX, aRayDirectionY, aRayDirectionZ):
    r"""


    void setShiftFilter(double aValue); void setScaleFilter(double aValue); double
    getShiftFilter(); double getScaleFilter();  

    """
    return _temp_gvxrPython3.rayIntersect(aLabel, aRayOriginX, aRayOriginY, aRayOriginZ, aRayDirectionX, aRayDirectionY, aRayDirectionZ)

def getMean(anImage):
    r"""


    Compute the arithmetic mean of a 1D array.  

    Parameters
    ----------
    * `anImage` :  
        the 1D array  

    Returns
    -------
    the arithmetic mean  

    """
    return _temp_gvxrPython3.getMean(anImage)

def getStddev(anImage):
    r"""


    Compute the standard deviation of a 1D array.  

    Parameters
    ----------
    * `anImage` :  
        the 1D array  

    Returns
    -------
    the standard deviation  

    """
    return _temp_gvxrPython3.getStddev(anImage)

def loadReference(aReferenceSet):
    r"""


    Load the reference data $(\theta)$ as a 1D array. It can be used with
    `computeZNCC` and `computeRMSE`.  

    Parameters
    ----------
    * `aReferenceSet` :  
        the 1st 1D array  

    """
    return _temp_gvxrPython3.loadReference(aReferenceSet)

def loadTest(aTestSet):
    r"""


    Load the test data $\left(\hat{\theta}\right)$ as a 1D array. It can be used
    with `computeZNCC` and `computeRMSE`.  

    Parameters
    ----------
    * `aTestSet` :  
        the 2nd 1D array  

    """
    return _temp_gvxrPython3.loadTest(aTestSet)

def lineariseTest(aThreshold, aScalingFactor):
    r"""


    Linearise the test data $\left(\hat{\theta}\right)$ as follows:  

    \begin{eqnarray*}   \hat{\theta}(i) = -\log(aScalingFactor \times
    \max(aThreshold, \hat{\theta}(i)))
    \end{eqnarray*}  

    Parameters
    ----------
    * `aThreshold` :  
        the 2nd 1D array  
    * `aScalingFactor` :  
        the 2nd 1D array  

    """
    return _temp_gvxrPython3.lineariseTest(aThreshold, aScalingFactor)

def loadImage2D(aFileName):
    r"""


    Load a 2D image from a file.  

    Parameters
    ----------
    * `aFileName` :  
        the file name of the 2D image  

    Returns
    -------
    the corresponding 2D image  

    """
    return _temp_gvxrPython3.loadImage2D(aFileName)

def loadImage3D(aFileName):
    r"""


    Load a 3D volume from a file.  

    Parameters
    ----------
    * `aFileName` :  
        the file name of the 3D volume  

    Returns
    -------
    the corresponding 3D volume  

    """
    return _temp_gvxrPython3.loadImage3D(aFileName)

def getMinValue(a3DVolume):
    r"""


    Find the smallest voxel value in a 3D volume.  

    Parameters
    ----------
    * `a3DVolume` :  
        the 3D volume  

    Returns
    -------
    the smallest voxel value  

    """
    return _temp_gvxrPython3.getMinValue(a3DVolume)

def getMaxValue(a3DVolume):
    r"""


    Find the largest voxel value in a 3D volume.  

    Parameters
    ----------
    * `a3DVolume` :  
        the 3D volume  

    Returns
    -------
    the largest voxel value  

    """
    return _temp_gvxrPython3.getMaxValue(a3DVolume)

def computeZNCC(*args):
    r"""


    Compute the zero-normalized cross-correlation (ZNCC) (also known as zero-mean
    unit-variance cross-correlation) between two 3D volumes. The ZNCC has a range of
    [-1, 1]. When the ZNCC is equal to -1, then the two volume are anticorrelated;
    when the ZNCC is equal to +1, then the two volume are fully correlated; and when
    the ZNCC is equal to 0, then the two volume are not correlated at all.  

    Parameters
    ----------
    * `aReferenceSet` :  
        the 1st 3D volume  
    * `aTestSet` :  
        the 2nd 3D volume  

    Returns
    -------
    the ZNCC between aReferenceSet and aTestSet  

    """
    return _temp_gvxrPython3.computeZNCC(*args)

def computeRMSE(*args):
    r"""


    Compute the root mean squared error (RMSE) (also known as root mean squared
    distance or root mean square deviation, RMSD) between two 3D volumes
    `aReferenceSet` $(\theta)$ and `aTestSet` $\left(\hat{\theta}\right)$. When
    RMSE is close to zero, then $\theta$ and $\hat{\theta}$ are similar.  

    \begin{eqnarray*}   MSE(\theta, \hat{\theta}) &=& \frac{\sum_{i =
    0}^{I-1}\sum_{j = 0}^{J-1}\sum_{k = 0}^{K-1}\left(\theta(i,j,k) -
    \hat{\theta}(i,j,k)\right)^2}{I \times J \times K}\\
       RMSE(\theta, \hat\theta)  &=& \sqrt{MSE\left(\theta,
    \hat\theta\right)}
    \end{eqnarray*}  

    Parameters
    ----------
    * `aReferenceSet` :  
        the 1st 3D volume  
    * `aTestSet` :  
        the 2nd 3D volume  

    Returns
    -------
    the RMSE between aReferenceSet and aTestSet  

    """
    return _temp_gvxrPython3.computeRMSE(*args)

def computeXRayImage(anIntegrateEnergyFlag=True):
    r"""


    Compute the X-ray projection corresponding to the environment that has
    previously been set, i.e.  

    *   Detector position  
    *   Detector orientation  
    *   Detector size and resolution  
    *   Source position  
    *   Source shape  
    *   Beam spectrum  
    *   Scanned object geometries  
    *   Scanned object material properties  

        Parameters:  
        * `anIntegrateEnergyFlag` :  
            if true the energy fluence is returned, otherwise the number of photons
            is returned (default value: true)  

        Returns:
        the corresponding X-ray image  

    """
    return _temp_gvxrPython3.computeXRayImage(anIntegrateEnergyFlag)

def computeSpectralImage():
    r"""


    Compute the spectral images corresponding to the environment that has previously
    been set, i.e.  

    *   Detector position  
    *   Detector orientation  
    *   Detector size and resolution  
    *   Source position  
    *   Source shape  
    *   Beam spectrum  
    *   Scanned object geometries  
    *   Scanned object material properties Note that there will be one 2D image per
        energy bin.  

        Returns:
        the corresponding spectral images  

    """
    return _temp_gvxrPython3.computeSpectralImage()

def computeLBuffer(aLabel):
    r"""


    Compute the L-buffer, i.e. path length, of a polygon mesh corresponding to the
    environment that has previously been set, i.e.  

    *   Detector position  
    *   Detector orientation  
    *   Detector size and resolution  
    *   Source position  
    *   Source shape  
    *   Scanned object geometry  

        Parameters:  
        * `aLabel` :  
            the label of the polygon mesh  

        Returns:
        the corresponding L-buffer  

    """
    return _temp_gvxrPython3.computeLBuffer(aLabel)

def computePathLength(aLabel):
    r"""


    Compute the L-buffer, i.e. path length, of a polygon mesh corresponding to the
    environment that has previously been set, i.e.  

    *   Detector position  
    *   Detector orientation  
    *   Detector size and resolution  
    *   Source position  
    *   Source shape  
    *   Scanned object geometry  

        Parameters:  
        * `aLabel` :  
            the label of the polygon mesh  

        Returns:
        the corresponding L-buffer  

    """
    return _temp_gvxrPython3.computePathLength(aLabel)

def computeSinogram(x, y, z, aUnitOfLength, aNumberOfAngle, anAngleOffset):
    r"""


    Compute the sinogram corresponding to the environment that has previously been
    set, i.e.  

    *   Detector position  
    *   Detector orientation  
    *   Detector size and resolution  
    *   Source position  
    *   Source shape  
    *   Beam spectrum  
    *   Scanned object geometries  
    *   Scanned object material properties Note that the rotation vector is the same
        as the up-vector of the detector.  

        Parameters:  
        * `x` :  
            the position of the rotation centre along the X-axis  
        * `y` :  
            the position of the rotation centre along the Y-axis  
        * `z` :  
            the position of the rotation centre along the Z-axis  
        * `aUnitOfLength` :  
            the unit of length corresponding to the x, y and z parameters.
            Acceptable values are: "um", "micrometre", "micrometer", "mm",
            "millimetre", "millimeter", "cm", "centimetre", "centimeter",
            "dm", "decimetre", "decimeter", "m", "metre", "meter",
            "dam", "decametre", "decameter", "hm", "hectometre",
            "hectometer", "km", "kilometre", "kilometer"  
        * `aNumberOfAngle` :  
            the total number of projections in the sinogram  
        * `anAngleOffset` :  
            the angle in degrees between two successive projections  

        Returns:
        the corresponding sinogram  

    """
    return _temp_gvxrPython3.computeSinogram(x, y, z, aUnitOfLength, aNumberOfAngle, anAngleOffset)

def computeProjectionSet(x, y, z, aUnitOfLength, aNumberOfAngle, anAngleOffset):
    r"""


    Compute the projection set corresponding to the environment that has previously
    been set, i.e.  

    *   Detector position  
    *   Detector orientation  
    *   Detector size and resolution  
    *   Source position  
    *   Source shape  
    *   Beam spectrum  
    *   Scanned object geometries  
    *   Scanned object material properties Note that the rotation vector is the same
        as the up-vector of the detector.  

        Parameters:  
        * `x` :  
            the position of the rotation centre along the X-axis  
        * `y` :  
            the position of the rotation centre along the Y-axis  
        * `z` :  
            the position of the rotation centre along the Z-axis  
        * `aUnitOfLength` :  
            the unit of length corresponding to the x, y and z parameters.
            Acceptable values are: "um", "micrometre", "micrometer", "mm",
            "millimetre", "millimeter", "cm", "centimetre", "centimeter",
            "dm", "decimetre", "decimeter", "m", "metre", "meter",
            "dam", "decametre", "decameter", "hm", "hectometre",
            "hectometer", "km", "kilometre", "kilometer"  
        * `aNumberOfAngle` :  
            the total number of projections in the projection set  
        * `anAngleOffset` :  
            the angle in degrees between two successive projections  

        Returns:
        the corresponding projection set  

    """
    return _temp_gvxrPython3.computeProjectionSet(x, y, z, aUnitOfLength, aNumberOfAngle, anAngleOffset)

def computeCTAcquisition(aProjectionOutputPath, aScreenshotOutputPath, aNumberOfProjections, aFirstAngle, anIncludeLastAngleFlag, aLastAngle, aNumberOfWhiteImagesInFlatField, aPositionOfCentreOfRotationX, aPositionOfCentreOfRotationY, aPositionOfCentreOfRotationZ, aUnitOfLength, aAxisOfRotationX, aAxisOfRotationY, aAxisOfRotationZ, anIntegrateEnergyFlag=True, aVerboseLevel=0):
    r"""


    Compute the X-ray projections for a CT acquisition.  

    Parameters
    ----------
    * `aProjectionOutputPath` :  
        the path where the X-ray projections will be saved. If the path is empty,
        the data will be stored in the main memory, but not saved on the disk. If
        the path is provided, the data will be saved on the disk, and the main
        memory released.  
    * `aScreenshotOutputPath` :  
        the path where the screenshots will be saved. If kept empty, not screenshot
        will be saved.  
    * `aNumberOfProjections` :  
        The total number of projections to simulate.  
    * `aFirstAngle` :  
        The rotation angle corresponding to the first projection.  
    * `anIncludeLastAngleFlag` :  
        A boolean flag to include or exclude the last angle. It is used to calculate
        the angular step between successive projections.  
    * `aLastAngle` :  
        The rotation angle corresponding to the last projection. Note that depending
        on the value of anIncludeLastAngleFlag, this angle may be included or
        excluded  
    * `aNumberOfWhiteImagesInFlatField` :  
        The number of white images used to perform the flat-field correction. If
        zero, then no correction will be performed.  
    * `aPositionOfCentreOfRotationX` :  
        The location of the rotation centre along the X-axis.  
    * `aPositionOfCentreOfRotationY` :  
        The location of the rotation centre along the Y-axis.  
    * `aPositionOfCentreOfRotationZ` :  
        The location of the rotation centre along the Z-axis.  
    * `aUnitOfLength` :  
        The corresponding unit of length  
    * `aAxisOfRotationX` :  
        The rotation axis along the X-axis.  
    * `aAxisOfRotationY` :  
        The rotation axis along the Y-axis.  
    * `aAxisOfRotationZ` :  
        The rotation axis along the Z-axis.  
    * `anIntegrateEnergyFlag` :  
        if true the energy fluence is returned, otherwise the number of photons is
        returned (default value: true)  
    * `aVerboseLevel` :  
        The verbose level. If greater than zero, details will be outputed (default
        value = 0)  

    """
    return _temp_gvxrPython3.computeCTAcquisition(aProjectionOutputPath, aScreenshotOutputPath, aNumberOfProjections, aFirstAngle, anIncludeLastAngleFlag, aLastAngle, aNumberOfWhiteImagesInFlatField, aPositionOfCentreOfRotationX, aPositionOfCentreOfRotationY, aPositionOfCentreOfRotationZ, aUnitOfLength, aAxisOfRotationX, aAxisOfRotationY, aAxisOfRotationZ, anIntegrateEnergyFlag, aVerboseLevel)

def getSourcePositionSet(aUnitOfLength):
    r"""


    Accessor on the set of successive source positions during the CT scan
    acquisition.  

    Returns
    -------
    the set of successive source positions  

    """
    return _temp_gvxrPython3.getSourcePositionSet(aUnitOfLength)

def getDetectorPositionSet(aUnitOfLength):
    r"""


    Accessor on the set of successive detector centre positions during the CT scan
    acquisition.  

    Returns
    -------
    the set of successive detector centre positions  

    """
    return _temp_gvxrPython3.getDetectorPositionSet(aUnitOfLength)

def getDetectorRightVectorSet():
    r"""


    Accessor on the set of successive unit vector that defines the horizontal axis
    of the detector.  

    Returns
    -------
    the set of successive unit vector that defines the horizontal axis of the
    detector  

    """
    return _temp_gvxrPython3.getDetectorRightVectorSet()

def getDetectorUpVectorSet():
    r"""


    Accessor on the set of successive unit vector that defines the vertical axis of
    the detector.  

    Returns
    -------
    the set of successive unit vector that defines the vertical axis of the detector  

    """
    return _temp_gvxrPython3.getDetectorUpVectorSet()

def getProjectionOutputPathCT():
    r"""


    Accessor on the path where X-ray projections are saved during a CT scan
    acquisition simulation.  

    Returns
    -------
    the path where X-ray projections are saved  

    """
    return _temp_gvxrPython3.getProjectionOutputPathCT()

def getScreenshotOutputPathCT():
    r"""


    Accessor on the path where screenshots are saved during a CT scan acquisition
    simulation.  

    Returns
    -------
    the path where screenshots are saved  

    """
    return _temp_gvxrPython3.getScreenshotOutputPathCT()

def getNumberOfProjectionsCT():
    r"""


    Accessor on the number of X-ray projections computed during a CT scan
    acquisition simulation.  

    Returns
    -------
    the number of X-ray projections  

    """
    return _temp_gvxrPython3.getNumberOfProjectionsCT()

def getOptimalNumberOfProjectionsCT():
    r"""


    Accessor on the number of X-ray projections needed to compute a CT scan
    acquisition that satisfies the Nyquist theorem. Note that the user may choose a
    different number.  

    Returns
    -------
    the optimal number of X-ray projections  

    """
    return _temp_gvxrPython3.getOptimalNumberOfProjectionsCT()

def getFirstAngleCT():
    r"""


    Accessor on the first angle of the CT scan acquisition simulation.  

    Returns
    -------
    the first angle  

    """
    return _temp_gvxrPython3.getFirstAngleCT()

def getLastAngleCT():
    r"""


    Accessor on the last angle of the CT scan acquisition simulation.  

    Returns
    -------
    the last angle  

    """
    return _temp_gvxrPython3.getLastAngleCT()

def getIncludeLastAngleFlagCT():
    r"""


    Accessor on the flag used to include the last angle or not during the CT scan
    acquisition simulation.  

    Returns
    -------
    the flag used to include the last angle or not  

    """
    return _temp_gvxrPython3.getIncludeLastAngleFlagCT()

def getWhiteImagesInFlatFieldCT():
    r"""


    Accessor on the number of white images used in the flat-field correction during
    the CT scan acquisition simulation. Zero means that the flat-field correction
    was not used.  

    Returns
    -------
    the number of white images  

    """
    return _temp_gvxrPython3.getWhiteImagesInFlatFieldCT()

def getCentreOfRotationPositionCT(aUnitOfLength):
    r"""


    Accessor on the position of the centre of rotation used during the CT scan
    acquisition simulation.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        The corresponding unit of length  

    Returns
    -------
    the position of the centre of rotation  

    """
    return _temp_gvxrPython3.getCentreOfRotationPositionCT(aUnitOfLength)

def getRotationAxisCT():
    r"""


    Accessor on the axis of rotation used during the CT scan acquisition simulation.  

    Returns
    -------
    the axis of rotation  

    """
    return _temp_gvxrPython3.getRotationAxisCT()

def getAngleSetCT():
    r"""


    Accessor on the set of rotation angles used during the CT scan acquisition
    simulation.  

    Returns
    -------
    the set of rotation angles  

    """
    return _temp_gvxrPython3.getAngleSetCT()

def getLastXRayImage():
    r"""


    Accessor on the last X-ray image that has been computed.  

    Returns
    -------
    the last X-ray image  

    """
    return _temp_gvxrPython3.getLastXRayImage()

def getLastLBuffer():
    r"""


    Accessor on the last L-buffer that has been computed.  

    Returns
    -------
    the last L-buffer  

    """
    return _temp_gvxrPython3.getLastLBuffer()

def getLastSinogram():
    r"""


    Accessor on the last sinogram that has been computed.  

    Returns
    -------
    the last sinogram  

    """
    return _temp_gvxrPython3.getLastSinogram()

def getLastProjectionSet():
    r"""


    Accessor on the last projection set that has been computed.  

    Returns
    -------
    the last projection set  

    """
    return _temp_gvxrPython3.getLastProjectionSet()

def saveLastXRayImage(*args):
    r"""


    Save the last X-ray image that has been computed.  

    Parameters
    ----------
    * `aFileName` :  
        the name of the output file (default: means that the filename will be
        automatically generated and the file saved in the current path)  
    * `useCompression` :  
        use data compression is possible (default: true)  

    """
    return _temp_gvxrPython3.saveLastXRayImage(*args)

def saveLastLBuffer(*args):
    r"""


    Save the last L-buffer, i.e. path length, that has been computed.  

    Parameters
    ----------
    * `aFileName` :  
        the name of the output file (default: means that the filename will be
        automatically generated and the file saved in the current path)  
    * `useCompression` :  
        use data compression is possible (default: true)  

    """
    return _temp_gvxrPython3.saveLastLBuffer(*args)

def saveLastPathLength(*args):
    r"""


    Save the last L-buffer, i.e. path length, that has been computed.  

    Parameters
    ----------
    * `aFileName` :  
        the name of the output file (default: means that the filename will be
        automatically generated and the file saved in the current path)  
    * `useCompression` :  
        use data compression is possible (default: true)  

    """
    return _temp_gvxrPython3.saveLastPathLength(*args)

def saveLastCumulatedLBuffer(*args):
    r"""


    Save the last cumulated L-buffer that has been computed.  

    Parameters
    ----------
    * `aFileName` :  
        the name of the output file (default: means that the filename will be
        automatically generated and the file saved in the current path)  
    * `useCompression` :  
        use data compression is possible (default: true)  

    """
    return _temp_gvxrPython3.saveLastCumulatedLBuffer(*args)

def saveLastSinogram(*args):
    r"""


    Save the last sinogram that has been computed.  

    Parameters
    ----------
    * `aFileName` :  
        the name of the output file (default: 0 means that the filename will be
        automatically generated and the file saved in the current path)  
    * `useCompression` :  
        use data compression is possible (default: true)  

    """
    return _temp_gvxrPython3.saveLastSinogram(*args)

def saveLastProjectionSet(*args):
    r"""


    Save the last projection set that has been computed.  

    Parameters
    ----------
    * `aFileName` :  
        the name of the output file (default: 0 means that the filename will be
        automatically generated and the file saved in the current path)  
    * `useCompression` :  
        use data compression is possible (default: true)  

    """
    return _temp_gvxrPython3.saveLastProjectionSet(*args)

def setDetectorNumberOfPixels(aWidth, aHeight):
    r"""


    Set the number of pixels of the X-ray detector.  

    Parameters
    ----------
    * `aWidth` :  
        the number of pixels along the X-axis  
    * `aHeight` :  
        the number of pixels along the Y-axis  

    """
    return _temp_gvxrPython3.setDetectorNumberOfPixels(aWidth, aHeight)

def getDetectorNumberOfPixels():
    r"""


    Accessor on the number of pixels of the X-ray detector.  

    Returns
    -------
    the size of the detector in number of pixels  

    """
    return _temp_gvxrPython3.getDetectorNumberOfPixels()

def setOversamplingFactor(aFactor=1):
    r"""


    Set the multiplicative factor to oversample the L-buffers.  

    Parameters
    ----------
    * `aFactor` :  
        the multiplicative factor (default value: 1, for no oversampling)  

    """
    return _temp_gvxrPython3.setOversamplingFactor(aFactor)

def getOversamplingFactor():
    r"""


    Accessor on the multiplicative factor to oversample the L-buffers.  

    Returns
    -------
    the multiplicative factor  

    """
    return _temp_gvxrPython3.getOversamplingFactor()

def setDetectorPixelSize(aWidth, aHeight, aUnitOfLength):
    r"""


    Set the pixel size. Same as the function setDetectorPixelPitch.  

    Parameters
    ----------
    * `aWidth` :  
        the pixel size along the X-axis  
    * `aHeight` :  
        the pixel size along the Y-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the aWidth and aHeight parameters.
        Acceptable values are: "um", "micrometre", "micrometer", "mm",
        "millimetre", "millimeter", "cm", "centimetre", "centimeter",
        "dm", "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.setDetectorPixelSize(aWidth, aHeight, aUnitOfLength)

def setDetectorPixelPitch(aWidth, aHeight, aUnitOfLength):
    r"""


    Set the pixel pitch. It is the distance between the centre of two pixels. It is
    often assumed that the edge of pixels have no width. Same as the function
    setDetectorPixelSize.  

    Parameters
    ----------
    * `aWidth` :  
        the pixel size along the X-axis  
    * `aHeight` :  
        the pixel size along the Y-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the aWidth and aHeight parameters.
        Acceptable values are: "um", "micrometre", "micrometer", "mm",
        "millimetre", "millimeter", "cm", "centimetre", "centimeter",
        "dm", "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.setDetectorPixelPitch(aWidth, aHeight, aUnitOfLength)

def getDetectorPixelSpacing(aUnitOfLength):
    r"""


    Accessor on the pixel spacing of the X-ray detector.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        the unit of length corresponding to the returned value. Acceptable values
        are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    Returns
    -------
    the size in a given unit of length  

    """
    return _temp_gvxrPython3.getDetectorPixelSpacing(aUnitOfLength)

def getDetectorSize(aUnitOfLength):
    r"""


    Accessor on the size of the X-ray detector.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        the unit of length corresponding to the returned value. Acceptable values
        are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    Returns
    -------
    the size in a given unit of length  

    """
    return _temp_gvxrPython3.getDetectorSize(aUnitOfLength)

def getDetectorPixelArea(aUnitOfLength):
    r"""


    Accessor on the area of a pixel of the X-ray detector.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        the unit of length corresponding to the returned value. Acceptable values
        are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    Returns
    -------
    the size in a given unit of length  

    """
    return _temp_gvxrPython3.getDetectorPixelArea(aUnitOfLength)

def setDetectorPosition(x, y, z, aUnitOfLength):
    r"""


    Set the position of the X-ray detector.  

    Parameters
    ----------
    * `x` :  
        the position along the X-axis  
    * `y` :  
        the position along the Y-axis  
    * `z` :  
        the position along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the x, y and z parameters. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.setDetectorPosition(x, y, z, aUnitOfLength)

def getDetectorPosition(aUnitOfLength):
    r"""


    Accessor on the position of the X-ray detector.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        the unit of length corresponding to the returned value. Acceptable values
        are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    Returns
    -------
    the source position in a given unit of length  

    """
    return _temp_gvxrPython3.getDetectorPosition(aUnitOfLength)

def setDetectorUpVector(x, y, z):
    r"""


    Set the up-vector defining the orientation of the X-ray detector.  

    Parameters
    ----------
    * `x` :  
        the component of the vector along the X-axis  
    * `y` :  
        the component of the vector along the Y-axis  
    * `z` :  
        the component of the vector along the Z-axis  

    """
    return _temp_gvxrPython3.setDetectorUpVector(x, y, z)

def getDetectorUpVector():
    r"""


    Accessor on the up-vector defining the orientation of the X-ray detector.  

    Returns
    -------
    the up-vector  

    """
    return _temp_gvxrPython3.getDetectorUpVector()

def setDetectorRightVector(x, y, z):
    r"""


    Set the right vector defining the orientation of the X-ray detector.  

    Parameters
    ----------
    * `x` :  
        the component of the vector along the X-axis  
    * `y` :  
        the component of the vector along the Y-axis  
    * `z` :  
        the component of the vector along the Z-axis  

    """
    return _temp_gvxrPython3.setDetectorRightVector(x, y, z)

def getDetectorRightVector():
    r"""


    Accessor on the right-vector defining the orientation of the X-ray detector.  

    Returns
    -------
    the right-vector  

    """
    return _temp_gvxrPython3.getDetectorRightVector()

def rotateDetector(anAngle, x, y, z):
    r"""


    Rotate the detector around a given axis.  

    Parameters
    ----------
    * `anAngle` :  
        the angle of rotation in degrees  
    * `x` :  
        the component of the rotation vector along the X-axis  
    * `y` :  
        the component of the rotation vector along the Y-axis  
    * `z` :  
        the component of the rotation vector along the Z-axis  

    """
    return _temp_gvxrPython3.rotateDetector(anAngle, x, y, z)

def autoAlignDetector(aFlag=True):
    r"""


    Set a flag to enable/disable the automatic alignment of the detector so that the
    ray from the middle of the source to the centre of the detector is perpendicular
    to both the unit vectors defining the horizontal and vertical axes of the
    detector.  

    Parameters
    ----------
    * `aFlag` :  
        the boolean flag (default value: true)  

    """
    return _temp_gvxrPython3.autoAlignDetector(aFlag)

def getDetectorVertices():
    r"""


    Accessor on the four corners of the X-ray detector.  

    Returns
    -------
    the corresponding vertices  

    """
    return _temp_gvxrPython3.getDetectorVertices()

def setLSF(*args):
    r"""


    Set the line spread function from an array.  

    Parameters
    ----------
    * `aLSF` :  
        the LSF coefficients  

    """
    return _temp_gvxrPython3.setLSF(*args)

def getLSF():
    r"""


    Accessor on the line spread function.  

    Returns
    -------
    the LSF coefficients  

    """
    return _temp_gvxrPython3.getLSF()

def clearLSF():
    r"""


    Clear the LSF to use a Dirac as impulse response.  

    """
    return _temp_gvxrPython3.clearLSF()

def setDetectorEnergyResponse(anEnergyResponse, aUnitOfEnergy):
    r"""


    Load the energy response of the detector from an array in the memory.  

    Parameters
    ----------
    * `anEnergyResponse` :  
        the energy response as an array. Each row of the array is formatted as
        follows: input_energy output_energy  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to the data in the array Acceptable values
        are: "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    """
    return _temp_gvxrPython3.setDetectorEnergyResponse(anEnergyResponse, aUnitOfEnergy)

def loadDetectorEnergyResponse(aFileName, aUnitOfEnergy):
    r"""


    Load the energy response of the detector from a TSV file.  

    Parameters
    ----------
    * `aFileName` :  
        name of the file. Each line of the file is formatted as follows:
        input_energy output_energy  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to the data in the file. Acceptable values
        are: "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    """
    return _temp_gvxrPython3.loadDetectorEnergyResponse(aFileName, aUnitOfEnergy)

def clearDetectorEnergyResponse():
    r"""


    Clear the energy response of the detector.  

    """
    return _temp_gvxrPython3.clearDetectorEnergyResponse()

def setScintillator(aMaterial, aThickness, aUnitOfLength):
    r"""


    Set the scintillator material of the detector. It will generate the energy
    response of the detector.  

    Parameters
    ----------
    * `aMaterial` :  
        the material of the scintillator. Acceptable values are: "CsI", "Cesium
        iodine", "CdWO4", "CWO", "Cadmium tungstate", "Y2O3", "Yttrium
        oxyde", "Gd2O3", "Gadolinum oxyde", "(Y,Gd)2O3", "YGO", "Yttrium
        gadolinum oxyde", "Gd2O2S", "Gadox", "Gadolinum silicate", "GOS",
        "Gd2O2S DRZ-Plus", "Gadox DRZ-Plus", "NaI", "Sodium iodine",
        "La2HfO7", "Lanthanum hafnate", "Gd3Ga5O12", "Gadolinium gallium
        garnet", "Y3Al5O12", "Yttrium aluminium garnate", "YAG"  
    * `aThickness` :  
        the thickness of the scintillator.  
    * `aUnitOfLength` :  
        the unit corresponding to the thickness of the scintillator. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.setScintillator(aMaterial, aThickness, aUnitOfLength)

def getScintillatorMaterial():
    r"""


    Accessor on the material of the scintillator of the detector.  

    Returns
    -------
    the material of the scintillator  

    """
    return _temp_gvxrPython3.getScintillatorMaterial()

def getSupportedScintillatorMaterials():
    r"""


    Accessor on the list of scintillator materials currently supported.  

    Returns
    -------
    the list of supported scintillator materials  

    """
    return _temp_gvxrPython3.getSupportedScintillatorMaterials()

def getEnergyResponse(*args):
    r"""


    Accessor on the energy response of a detector scintillator of a given material
    and thickness.  

    Parameters
    ----------
    * `aMaterial` :  
        the material of the scintillator. Acceptable values are: "CsI", "Cesium
        iodine", "CdWO4", "CWO", "Cadmium tungstate", "Y2O3", "Yttrium
        oxyde", "Gd2O3", "Gadolinum oxyde", "(Y,Gd)2O3", "YGO", "Yttrium
        gadolinum oxyde", "Gd2O2S", "Gadox", "Gadolinum silicate", "GOS",
        "Gd2O2S DRZ-Plus", "Gadox DRZ-Plus", "NaI", "Sodium iodine",
        "La2HfO7", "Lanthanum hafnate", "Gd3Ga5O12", "Gadolinium gallium
        garnet", "Y3Al5O12", "Yttrium aluminium garnate", "YAG"  
    * `aThickness` :  
        the thickness of the scintillator.  
    * `aUnitOfLength` :  
        the unit corresponding to the thickness of the scintillator. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to the data in the array. Acceptable values
        are: "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the corresponding energy response  

    """
    return _temp_gvxrPython3.getEnergyResponse(*args)

def getScintillatorThickness(aUnitOfLength):
    r"""


    Accessor on the thickness of the scintillator of the detector.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        the unit corresponding to the thickness of the scintillator. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    Returns
    -------
    the thickness of the scintillator  

    """
    return _temp_gvxrPython3.getScintillatorThickness(aUnitOfLength)

def setPhotonCountingBands(aMinEnergy, aMaxEnergy, aUnitOfEnergy, aNumberOfBands):
    r"""


    Define the energy bands of a spectral detector. Photon counting will be used.  

    Parameters
    ----------
    * `aMinEnergy` :  
        the lower energy threshod  
    * `aMaxEnergy` :  
        the upper energy threshod  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to aMinEnergy and aMaxEnergy. Acceptable
        values are: "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  
    * `aNumberOfBands` :  
        the number of energy bands  

    """
    return _temp_gvxrPython3.setPhotonCountingBands(aMinEnergy, aMaxEnergy, aUnitOfEnergy, aNumberOfBands)

def getNumberOfPhotonCountingBands():
    r"""


    Accessor on the number of energy bands of the spectral detector.  

    Returns
    -------
    the number of energy bands of the spectral detector  

    """
    return _temp_gvxrPython3.getNumberOfPhotonCountingBands()

def mergePhotonCountingBands():
    r"""


    Merge all the energy bands. In this case a typical detector will be used and
    it'll integrate the energy.  

    """
    return _temp_gvxrPython3.mergePhotonCountingBands()

def getPhotonCountingBands(aUnitOfEnergy):
    r"""


    Accessor on the energy bands when a spectral detector is used.  

    Parameters
    ----------
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to energies in the bands. Acceptable values
        are: "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the set of energy bands  

    """
    return _temp_gvxrPython3.getPhotonCountingBands(aUnitOfEnergy)

def getNumberOfImplicitSurfaces():
    r"""


    Get the total number of implicit surfaces that have been added to the
    scenegraph.  

    Returns
    -------
    the number of implicit surfaces  

    """
    return _temp_gvxrPython3.getNumberOfImplicitSurfaces()

def getImplicitSurfaceLabelSet():
    r"""


    Get the labels of all the implicit surfaces that have been added to the
    scenegraph.  

    Returns
    -------
    the set of implicit surface labels  

    """
    return _temp_gvxrPython3.getImplicitSurfaceLabelSet()

def implicitSurfaceExists(aLabel):
    r"""


    Check whether a given label is used to identify an implicit surface.  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying a potential implicit surface  

    Returns
    -------
    true if the label identify an implicit surface, otherwise retrun false  

    """
    return _temp_gvxrPython3.implicitSurfaceExists(aLabel)

def createImplicitSurface(aLabel):
    r"""


    Create a new implicit surface.  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying the new implicit surface  

    """
    return _temp_gvxrPython3.createImplicitSurface(aLabel)

def destroyImplicitSurface(aLabel):
    r"""


    Destroy a given implicit surface.  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying the implicit surface  

    """
    return _temp_gvxrPython3.destroyImplicitSurface(aLabel)

def destroyAllImplicitSurfaces():
    r"""


    Destroy all the existing implicit surfaces.  

    """
    return _temp_gvxrPython3.destroyAllImplicitSurfaces()

def addControlPoint(aLabel, aPositionX, aPositionY, aPositionZ, aUnitOfLength, aDentityFunction, aParameterA, aParameterB=0.0):
    r"""


    Add a control point to an existing implicit surface. See the excellent webpage
    by Paul Bourke: https://paulbourke.net/geometry/implicitsurf/index.html.  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying the implicit surface  
    * `aPositionX` :  
        the position of the point along the X-axis  
    * `aPositionY` :  
        the position of the point along the Y-axis  
    * `aPositionZ` :  
        the position of the point along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to aPositionX, aPositionY and aPositionZ.
        Acceptable values are: "um", "micrometre", "micrometer", "mm",
        "millimetre", "millimeter", "cm", "centimetre", "centimeter",
        "dm", "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  
    * `aDentityFunction` :  
        the name of the density function. Accepted values are:  
         "sphere", which uses the density function $D(r) = \frac{1}{r^2}$.  
         "blobby molecule", which uses the density density function $a
        \mathrm{e}^{-b r^2}$  $b$ is related to the standard deviation of the
        curve, $a$ to the height. The function should be recognised as a Gaussian
        curve centered at the origin, actually a half Gaussian as $r \geq 0$.  
         "metaball", which uses the density function       $\left\{
                                 \begin{array}{ c l }
                                    a \left(1 - \frac{3 r^2}{b^2}\right) & \quad
        \textrm{if } 0 \leq r \leq b/3 \\
                                    \frac{3 a}{2} \left(1 - \frac{r}{b}\right)^2
        & \quad \textrm{if } b/3 \leq r \leq b \\
                                     0                 & \quad \textrm{otherwise}
                                 \end{array}
                                 \right.$  $a$ is a scaling factor, $b$ is the
        maximum distance a control primitive contributes to the field.  
         "soft object", which uses the density function      $\left\{
                                 \begin{array}{ c l }
                                    a \left(1 - \frac{4r^6}{9b^6} +
        \frac{17r^4}{9b^4} - \frac{22r^2}{9b^2}\right) & \quad \textrm{if } 0
        \leq r \leq b \\
                                     0                 & \quad \textrm{otherwise}
                                 \end{array}
                                 \right.$  $a$ scales the function, each control
        primitive has no influence after a distance $b$. This function has a slight
        advantage over that for Meta balls as it only uses squares of the distance
        and so it isn't necessary to compute square roots.  
    * `aParameterA` :  
        $a$ in the equations above  
    * `aParameterB` :  
        $b$ in the equations above (default value: 0.0)  

    """
    return _temp_gvxrPython3.addControlPoint(aLabel, aPositionX, aPositionY, aPositionZ, aUnitOfLength, aDentityFunction, aParameterA, aParameterB)

def addControlLineSegment(aLabel, aPosition1X, aPosition1Y, aPosition1Z, aPosition2X, aPosition2Y, aPosition2Z, aUnitOfLength, aDentityFunction, aParameterA, aParameterB=0.0):
    r"""


    Add a control point to an existing implicit surface. See the excellent webpage
    by Paul Bourke: https://paulbourke.net/geometry/implicitsurf/index.html.  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying the implicit surface  
    * `aPosition1X` :  
        the position of the 1st point defining the line segment along the X-axis  
    * `aPosition1Y` :  
        the position of the 1st point defining the line segment along the Y-axis  
    * `aPosition1Z` :  
        the position of the 1st point defining the line segment along the Z-axis  
    * `aPosition2X` :  
        the position of the 2nd point defining the line segment along the X-axis  
    * `aPosition2Y` :  
        the position of the 2nd point defining the line segment along the Y-axis  
    * `aPosition2Z` :  
        the position of the 2nd point defining the line segment along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to aPositionX, aPositionY and aPositionZ.
        Acceptable values are: "um", "micrometre", "micrometer", "mm",
        "millimetre", "millimeter", "cm", "centimetre", "centimeter",
        "dm", "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  
    * `aDentityFunction` :  
        the name of the density function. Accepted values are:  
         "sphere", which uses the density function $D(r) = \frac{1}{r^2}$.  
         "blobby molecule", which uses the density density function $a
        \mathrm{e}^{-b r^2}$  $b$ is related to the standard deviation of the
        curve, $a$ to the height. The function should be recognised as a Gaussian
        curve centered at the origin, actually a half Gaussian as $r \geq 0$.  
         "metaball", which uses the density function       $\left\{
                                 \begin{array}{ c l }
                                    a \left(1 - \frac{3 r^2}{b^2}\right) & \quad
        \textrm{if } 0 \leq r \leq b/3 \\
                                    \frac{3 a}{2} \left(1 - \frac{r}{b}\right)^2
        & \quad \textrm{if } b/3 \leq r \leq b \\
                                     0                 & \quad \textrm{otherwise}
                                 \end{array}
                                 \right.$  $a$ is a scaling factor, $b$ is the
        maximum distance a control primitive contributes to the field.  
         "soft object", which uses the density function      $\left\{
                                 \begin{array}{ c l }
                                    a \left(1 - \frac{4r^6}{9b^6} +
        \frac{17r^4}{9b^4} - \frac{22r^2}{9b^2}\right) & \quad \textrm{if } 0
        \leq r \leq b \\
                                     0                 & \quad \textrm{otherwise}
                                 \end{array}
                                 \right.$  $a$ scales the function, each control
        primitive has no influence after a distance $b$. This function has a slight
        advantage over that for Meta balls as it only uses squares of the distance
        and so it isn't necessary to compute square roots.  
    * `aParameterA` :  
        $a$ in the equations above  
    * `aParameterB` :  
        $b$ in the equations above (default value: 0.0)  

    """
    return _temp_gvxrPython3.addControlLineSegment(aLabel, aPosition1X, aPosition1Y, aPosition1Z, aPosition2X, aPosition2Y, aPosition2Z, aUnitOfLength, aDentityFunction, aParameterA, aParameterB)

def getNumberOfControlPoints(aLabel):
    r"""


    Accessor on the total number of control points in a given implicit surface.  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying the implicit surface  

    Returns
    -------
    the total number of control points in the implicit surface  

    """
    return _temp_gvxrPython3.getNumberOfControlPoints(aLabel)

def getNumberOfControlLineSegments(aLabel):
    r"""


    Accessor on the total number of control line segments in a given implicit
    surface.  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying the implicit surface  

    Returns
    -------
    the total number of line segments in the implicit surface  

    """
    return _temp_gvxrPython3.getNumberOfControlLineSegments(aLabel)

def setControlPointParameters(aLabel, aPointID, aDentityFunction, aParameterA, aParameterB=0.0):
    r"""


    Change the density function and the parameters $a$ and $b$ of a given control
    point of a given implicit surface.  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying the implicit surface  
    * `aPointID` :  
        the numerial ID of the control point  
    * `aDentityFunction` :  
        the name of the density function. Accepted values are:  
         "sphere", which uses the density function $D(r) = \frac{1}{r^2}$.  
         "blobby molecule", which uses the density density function $a
        \mathrm{e}^{-b r^2}$  $b$ is related to the standard deviation of the
        curve, $a$ to the height. The function should be recognised as a Gaussian
        curve centered at the origin, actually a half Gaussian as $r \geq 0$.  
         "metaball", which uses the density function       $\left\{
                                 \begin{array}{ c l }
                                    a \left(1 - \frac{3 r^2}{b^2}\right) & \quad
        \textrm{if } 0 \leq r \leq b/3 \\
                                    \frac{3 a}{2} \left(1 - \frac{r}{b}\right)^2
        & \quad \textrm{if } b/3 \leq r \leq b \\
                                     0                 & \quad \textrm{otherwise}
                                 \end{array}
                                 \right.$  $a$ is a scaling factor, $b$ is the
        maximum distance a control primitive contributes to the field.  
         "soft object", which uses the density function      $\left\{
                                 \begin{array}{ c l }
                                    a \left(1 - \frac{4r^6}{9b^6} +
        \frac{17r^4}{9b^4} - \frac{22r^2}{9b^2}\right) & \quad \textrm{if } 0
        \leq r \leq b \\
                                     0                 & \quad \textrm{otherwise}
                                 \end{array}
                                 \right.$  $a$ scales the function, each control
        primitive has no influence after a distance $b$. This function has a slight
        advantage over that for Meta balls as it only uses squares of the distance
        and so it isn't necessary to compute square roots.  
    * `aParameterA` :  
        $a$ in the equations above  
    * `aParameterB` :  
        $b$ in the equations above  

    """
    return _temp_gvxrPython3.setControlPointParameters(aLabel, aPointID, aDentityFunction, aParameterA, aParameterB)

def setControlLineSegmentParameters(aLabel, aLineSegmentID, aDentityFunction, aParameterA, aParameterB=0.0):
    r"""


    Change the density function and the parameters $a$ and $b$ of a given control
    line segment of a given implicit surface.  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying the implicit surface  
    * `aLineSegmentID` :  
        the numerial ID of the control line segment  
    * `aDentityFunction` :  
        the name of the density function. Accepted values are:  
         "sphere", which uses the density function $D(r) = \frac{1}{r^2}$.  
         "blobby molecule", which uses the density density function $a
        \mathrm{e}^{-b r^2}$  $b$ is related to the standard deviation of the
        curve, $a$ to the height. The function should be recognised as a Gaussian
        curve centered at the origin, actually a half Gaussian as $r \geq 0$.  
         "metaball", which uses the density function       $\left\{
                                 \begin{array}{ c l }
                                    a \left(1 - \frac{3 r^2}{b^2}\right) & \quad
        \textrm{if } 0 \leq r \leq b/3 \\
                                    \frac{3 a}{2} \left(1 - \frac{r}{b}\right)^2
        & \quad \textrm{if } b/3 \leq r \leq b \\
                                     0                 & \quad \textrm{otherwise}
                                 \end{array}
                                 \right.$  $a$ is a scaling factor, $b$ is the
        maximum distance a control primitive contributes to the field.  
         "soft object", which uses the density function      $\left\{
                                 \begin{array}{ c l }
                                    a \left(1 - \frac{4r^6}{9b^6} +
        \frac{17r^4}{9b^4} - \frac{22r^2}{9b^2}\right) & \quad \textrm{if } 0
        \leq r \leq b \\
                                     0                 & \quad \textrm{otherwise}
                                 \end{array}
                                 \right.$  $a$ scales the function, each control
        primitive has no influence after a distance $b$. This function has a slight
        advantage over that for Meta balls as it only uses squares of the distance
        and so it isn't necessary to compute square roots.  
    * `aParameterA` :  
        $a$ in the equations above  
    * `aParameterB` :  
        $b$ in the equations above  

    """
    return _temp_gvxrPython3.setControlLineSegmentParameters(aLabel, aLineSegmentID, aDentityFunction, aParameterA, aParameterB)

def voxeliseImplicitSurface(aLabel, aNumberOfVoxelX, aNumberOfVoxelY, aNumberOfVoxelZ, aCentrePositionX, aCentrePositionY, aCentrePositionZ, aVoxelWidth, aVoxelHeight, aVoxelDepth, aUnitOfLength, aVerboseLevel=0):
    r"""


    Compute the density function of a given implicit surface. It create a volume
    (i.e. voxels)  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying the implicit surface  
    * `aNumberOfVoxelX` :  
        the number of voxels along the X-axis  
    * `aNumberOfVoxelY` :  
        the number of voxels along the Y-axis  
    * `aNumberOfVoxelZ` :  
        the number of voxels along the Z-axis  
    * `aCentrePositionX` :  
        the position of the centre of the volume along the X-axis  
    * `aCentrePositionY` :  
        the position of the centre of the volume along the Y-axis  
    * `aCentrePositionZ` :  
        the position of the centre of the volume along the Z-axis  
    * `aVoxelWidth` :  
        the size of a voxel along the X-axis  
    * `aVoxelHeight` :  
        the size of a voxel along the Y-axis  
    * `aVoxelDepth` :  
        the size of a voxel along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to aCentrePositionX, aCentrePositionY,
        aCentrePositionZ, aVoxelWidth, aVoxelHeight and aVoxelDepth. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  
    * `aVerboseLevel` :  
        the level of statements in the standard output. For no output, use 0
        (default value: 0)  

    """
    return _temp_gvxrPython3.voxeliseImplicitSurface(aLabel, aNumberOfVoxelX, aNumberOfVoxelY, aNumberOfVoxelZ, aCentrePositionX, aCentrePositionY, aCentrePositionZ, aVoxelWidth, aVoxelHeight, aVoxelDepth, aUnitOfLength, aVerboseLevel)

def voxelizeImplicitSurface(aLabel, aNumberOfVoxelX, aNumberOfVoxelY, aNumberOfVoxelZ, aCentrePositionX, aCentrePositionY, aCentrePositionZ, aVoxelWidth, aVoxelHeight, aVoxelDepth, aUnitOfLength, aVerboseLevel=0):
    r"""


    Compute the density function of a given implicit surface. It create a volume
    (i.e. voxels)  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying the implicit surface  
    * `aNumberOfVoxelX` :  
        the number of voxels along the X-axis  
    * `aNumberOfVoxelY` :  
        the number of voxels along the Y-axis  
    * `aNumberOfVoxelZ` :  
        the number of voxels along the Z-axis  
    * `aCentrePositionX` :  
        the position of the centre of the volume along the X-axis  
    * `aCentrePositionY` :  
        the position of the centre of the volume along the Y-axis  
    * `aCentrePositionZ` :  
        the position of the centre of the volume along the Z-axis  
    * `aVoxelWidth` :  
        the size of a voxel along the X-axis  
    * `aVoxelHeight` :  
        the size of a voxel along the Y-axis  
    * `aVoxelDepth` :  
        the size of a voxel along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to aCentrePositionX, aCentrePositionY,
        aCentrePositionZ, aVoxelWidth, aVoxelHeight and aVoxelDepth. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  
    * `aVerboseLevel` :  
        the level of statements in the standard output. For no output, use 0
        (default value: 0)  

    """
    return _temp_gvxrPython3.voxelizeImplicitSurface(aLabel, aNumberOfVoxelX, aNumberOfVoxelY, aNumberOfVoxelZ, aCentrePositionX, aCentrePositionY, aCentrePositionZ, aVoxelWidth, aVoxelHeight, aVoxelDepth, aUnitOfLength, aVerboseLevel)

def getImplicitSurfaceLastVoxelisation(aLabel):
    r"""


    Accessor on the last voxelisation of a given iso-surface that has been computed.  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying the polygon mesh in the scenegraph  

    Returns
    -------
    the last voxelisation  

    """
    return _temp_gvxrPython3.getImplicitSurfaceLastVoxelisation(aLabel)

def getImplicitSurfaceLastVoxelization(aLabel):
    r"""


    Accessor on the last voxelisation of a given iso-surface that has been computed.  

    Parameters
    ----------
    * `aLabel` :  
        the label identifying the polygon mesh in the scenegraph  

    Returns
    -------
    the last voxelisation  

    """
    return _temp_gvxrPython3.getImplicitSurfaceLastVoxelization(aLabel)

def createMeshFromImplicitSurface(*args):
    r"""


    Apply the marching cubes algorithm to extract the polygon mesh and add the node
    in the scenegraph.  

    Parameters
    ----------
    * `aImplicitSurfaceLabel` :  
        the label identifying the implicit surface  
    * `aMeshLabel` :  
        the label identifying the polygon mesh in the scenegraph  
    * `aLowerIsoValue` :  
        the lower limit of the iso value  
    * `anUpperIsoValue` :  
        the upper limit of the the iso value  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  
    * `aVerboseLevel` :  
        the level of statements in the standard output. For no output, use 0
        (default value: 0)  

    """
    return _temp_gvxrPython3.createMeshFromImplicitSurface(*args)

def loadMeshFile(*args):
    r"""


    Load a polygon mesh from a file, set its label in the scenegraph (i.e.
    identifier) and add it to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aFileName` :  
        the file where the polygon mesh data is stored  
    * `aUnitOfLength` :  
        the unit of length corresponding to the data stored in the file. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  
    * `addToRendererAsInnerSurface` :  
        a flag to add the mesh to the X-ray renderer (as an inner surface) (default
        value: true)  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _temp_gvxrPython3.loadMeshFile(*args)

def getMeshFilename(aLabel):
    r"""


    Accessor on the filename of the mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the filename  

    """
    return _temp_gvxrPython3.getMeshFilename(aLabel)

def getMeshUnitOfLength(aLabel):
    r"""


    Accessor on the unit of length of the mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the unit of length  

    """
    return _temp_gvxrPython3.getMeshUnitOfLength(aLabel)

def loadSceneGraph(aFileName, aUnitOfLength):
    r"""


    Load a scenegraph from a file and add its polygon meshes to the X-ray renderer.  

    Parameters
    ----------
    * `aFileName` :  
        the file where the polygon mesh data is stored  
    * `aUnitOfLength` :  
        the unit of length corresponding to the data stored in the file. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.loadSceneGraph(aFileName, aUnitOfLength)

def getNumberOfPrimitives(aLabel):
    r"""


    Accessor on the number of primitives of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the number of primitives  

    """
    return _temp_gvxrPython3.getNumberOfPrimitives(aLabel)

def getNumberOfFaceNormalVectors(aLabel):
    r"""


    Accessor on the number of face normal vectors of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the number of face normal vectors  

    """
    return _temp_gvxrPython3.getNumberOfFaceNormalVectors(aLabel)

def getNumberOfVertexNormalVectors(aLabel):
    r"""


    Accessor on the number of vertex normal vectors of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the number of vertex normal vectors  

    """
    return _temp_gvxrPython3.getNumberOfVertexNormalVectors(aLabel)

def getVertexNumber(aLabel):
    r"""


    Accessor on the number of verticesof a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the number of vertices  

    """
    return _temp_gvxrPython3.getVertexNumber(aLabel)

def getIndexNumber(aLabel):
    r"""


    Accessor on the number of indicesof a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the number of indices  

    """
    return _temp_gvxrPython3.getIndexNumber(aLabel)

def getVertexSet(aLabel):
    r"""


    Accessor on the vertices of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the vertex  

    """
    return _temp_gvxrPython3.getVertexSet(aLabel)

def getFaceNormalVectorSet(aLabel):
    r"""


    Accessor on the face normals of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the face normals  

    """
    return _temp_gvxrPython3.getFaceNormalVectorSet(aLabel)

def getVertexNormalVectorSet(aLabel):
    r"""


    Accessor on the vertex normals of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the vertex normals  

    """
    return _temp_gvxrPython3.getVertexNormalVectorSet(aLabel)

def getIndexSet(aLabel):
    r"""


    Accessor on the set of indices of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the set of indices  

    """
    return _temp_gvxrPython3.getIndexSet(aLabel)

def isInnerSurface(aLabel):
    r"""


    Check if a given node is an innersurface ("an" because there can be many).  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    true if the node is an inner surface, otherwise false  

    """
    return _temp_gvxrPython3.isInnerSurface(aLabel)

def isOuterSurface(aLabel):
    r"""


    Check if a given node is the outer surface ("the" because there can only be
    one).  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    true if the node is the outer surface, otherwise false  

    """
    return _temp_gvxrPython3.isOuterSurface(aLabel)

def emptyMesh(*args):
    r"""


    Create an empty polygon mesh and set its label in the scenegraph (i.e.
    identifier). Note that it is not added to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _temp_gvxrPython3.emptyMesh(*args)

def removeMeshAndChildren(aLabel):
    r"""


    Remove and delete a polygon mesh from the scenegraph (i.e. identifier). Note
    that all its children, if any, will be removed too.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    """
    return _temp_gvxrPython3.removeMeshAndChildren(aLabel)

def makeCube(*args):
    r"""


    Create a cube, centred on (0, 0, 0) and set its label in the scenegraph (i.e.
    identifier). Note that it is not added to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aLength` :  
        the size of an edge of the cube (default value: 1)  
    * `aUnitOfLength` :  
        the unit of length corresponding to aLength. Acceptable values are: "um",
        "micrometre", "micrometer", "mm", "millimetre", "millimeter",
        "cm", "centimetre", "centimeter", "dm", "decimetre",
        "decimeter", "m", "metre", "meter", "dam", "decametre",
        "decameter", "hm", "hectometre", "hectometer", "km",
        "kilometre", "kilometer" (default value: "cm")  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _temp_gvxrPython3.makeCube(*args)

def makeCuboid(*args):
    r"""


    Create a cuboid, centred on (0, 0, 0) and set its label in the scenegraph (i.e.
    identifier). Note that it is not added to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aWidth` :  
        the width of the cuboid, i.e. its length along the X-axis (default value: 1)  
    * `aHeight` :  
        the height of the cuboid, i.e. its length along the Y-axis (default value:
        1)  
    * `aDepth` :  
        the depth of the cuboid, i.e. its length along the Z-axis (default value: 1)  
    * `aUnitOfLength` :  
        the unit of length corresponding to aLength. Acceptable values are: "um",
        "micrometre", "micrometer", "mm", "millimetre", "millimeter",
        "cm", "centimetre", "centimeter", "dm", "decimetre",
        "decimeter", "m", "metre", "meter", "dam", "decametre",
        "decameter", "hm", "hectometre", "hectometer", "km",
        "kilometre", "kilometer" (default value: "cm")  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _temp_gvxrPython3.makeCuboid(*args)

def makeCylinder(*args):
    r"""


    Create a cylinder and set its label in the scenegraph (i.e. identifier). Note
    that it is not added to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aNumberOfSectors` :  
        the number of sectors defining the mesh (default value: 10)  
    * `aHeight` :  
        the height of the cylinder (default value: 1.0)  
    * `aRadius` :  
        the radius of the cylinder (default value: 0.5)  
    * `aUnitOfLength` :  
        the unit of length corresponding to aHeight and aRadius. Acceptable values
        are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer" (default value: "cm")  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _temp_gvxrPython3.makeCylinder(*args)

def makeSphere(*args):
    r"""


    Create a sphere and set its label in the scenegraph (i.e. identifier). Note that
    it is not added to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aNumberOfRings` :  
        the number of rings defining the mesh (default value: 10)  
    * `aNumberOfSectors` :  
        the number of sectors defining the mesh (default value: 10)  
    * `aRadius` :  
        the radius of the sphere (default value: 0.5)  
    * `aUnitOfLength` :  
        the unit of length corresponding to aRadius. Acceptable values are: "um",
        "micrometre", "micrometer", "mm", "millimetre", "millimeter",
        "cm", "centimetre", "centimeter", "dm", "decimetre",
        "decimeter", "m", "metre", "meter", "dam", "decametre",
        "decameter", "hm", "hectometre", "hectometer", "km",
        "kilometre", "kilometer" (default value: "cm")  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _temp_gvxrPython3.makeSphere(*args)

def makeStepWedge(*args):
    r"""


    Create a step wedge and set its label in the scenegraph (i.e. identifier). Note
    that it is not added to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aNumberOfSteps` :  
        the number of steps in the stepwedge (default value: 10)  
    * `aTotalLength` :  
        the length of the step wedge, i.e. its length along the X-axis (default
        value: 10)  
    * `aWidth` :  
        the width of the step wedge, i.e. its length along the Y-axis (default
        value: 1)  
    * `aFirstStepHeight` :  
        the height of the first step on the step wedge, i.e. its length along the
        Z-axis (default value: 1)  
    * `anOtherStepHeight` :  
        the height of the rest of the steps on the step wedge, i.e. its length along
        the Z-axis (default value: 0.1)  
    * `aUnitOfLength` :  
        the unit of length corresponding to aRadius. Acceptable values are: "um",
        "micrometre", "micrometer", "mm", "millimetre", "millimeter",
        "cm", "centimetre", "centimeter", "dm", "decimetre",
        "decimeter", "m", "metre", "meter", "dam", "decametre",
        "decameter", "hm", "hectometre", "hectometer", "km",
        "kilometre", "kilometer" (default value: "cm")  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _temp_gvxrPython3.makeStepWedge(*args)

def makeIsoSurface(*args):
    r"""


    Create an iso-surface from a 3D image and set its label in the scenegraph (i.e.
    identifier). Note that it is not added to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `anIsoValue` :  
        the iso-value  
    * `aVoxelDataSet` :  
        the voxel dataset  
    * `aWidth` :  
        the number of voxel along the X-axis  
    * `aHeight` :  
        the number of voxel along the Y-axis  
    * `aDepth` :  
        the number of voxel along the Z-axis  
    * `aSpacingX` :  
        the space between the centre of two successive voxels along the X-axis  
    * `aSpacingY` :  
        the space between the centre of two successive voxels along the Y-axis  
    * `aSpacingZ` :  
        the space between the centre of two successive voxels along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to aSpacingX, aSpacingY and aSpacingZ.
        Acceptable values are: "um", "micrometre", "micrometer", "mm",
        "millimetre", "millimeter", "cm", "centimetre", "centimeter",
        "dm", "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer" (default value: "cm")  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _temp_gvxrPython3.makeIsoSurface(*args)

def makeFoamInCuboid(aPorosityName, aBoundingVolumeName, aCuboidWidth, aCuboidHeight, aCuboidDepth, aPorosityRadius, aPercentageOfVolume, aPercentageDeviation, aVoxelSpacing, aUnitOfLength, aVerboseLevel=0):
    r"""


    Create a foam structure, i.e. porosities into a bounding volume. Deprecated
    function: The parameter aBoundingVolumeName is not used. The function will be
    removed in future versions.  

    Parameters
    ----------
    * `aPorosityName` :  
        the label of the prorosities in the scenegraph  
    * `aBoundingVolumeName` :  
        the label of the bounding volume in the scenegraph  
    * `aCuboidWidth` :  
        the width of the cuboid, i.e. its length along the X-axis  
    * `aCuboidHeight` :  
        the height of the cuboid, i.e. its length along the Y-axis  
    * `aCuboidDepth` :  
        the depth of the cuboid, i.e. its length along the Z-axis  
    * `aPorosityRadius` :  
        Tuple of the mean radius and statistical deviation for foam holes created.  
    * `aPercentageOfVolume` :  
        : Percentage of the enclosing volume occupied by foam pores  
    * `aPercentageDeviation` :  
        : The standard deviation relative to the radius in percentage (Default is
        10%)  
    * `aVoxelSpacing` :  
        : Spacing (or resolution) of the voxels in cube.  
    * `aUnitOfLength` :  
        the unit of length corresponding to aRadius and aVoxelSpacing. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  
    * `aVerboseLevel` :  
        the level of statements in the standard output. For no output, use 0
        (default value: 0)  

    """
    return _temp_gvxrPython3.makeFoamInCuboid(aPorosityName, aBoundingVolumeName, aCuboidWidth, aCuboidHeight, aCuboidDepth, aPorosityRadius, aPercentageOfVolume, aPercentageDeviation, aVoxelSpacing, aUnitOfLength, aVerboseLevel)

def makeTriangularMesh(*args):
    r"""


    Create a triangular mesh structure from a set of vertices and a set of indices.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the node to create in the scenegraph  
    * `aVertexSet` :  
        the set of vertices  
    * `aTriangleIndexSet` :  
        the set of indices  
    * `aUnitOfLength` :  
        the unit of length corresponding to aVertexSet. Acceptable values are:
        "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _temp_gvxrPython3.makeTriangularMesh(*args)

def makeSpheresInCylinder(*args):
    r"""


    Create a cylinder in which spheres are embedded. The cylinder is centred on (0,
    0, 0) and the spheres are randomly positioned in the cylinder. Note that it is
    not added to the X-ray renderer.  

    Parameters
    ----------
    * `aCylinderLabel` :  
        the cylinder label in the scenegraph  
    * `aCylinderNumberOfSectors` :  
        the number of sectors defining the mesh  
    * `aCylinderRadius` :  
        the radius of the cylinder  
    * `aCylinderHeight` :  
        the height of the cylinder  
    * `aSphereLabel` :  
        the sphere label in the scenegraph  
    * `aSphereNumberOfRings` :  
        the number of rings defining the mesh  
    * `aSphereNumberOfSectors` :  
        the number of sectors defining the mesh  
    * `aSphereRadius` :  
        the radius of the cylinder  
    * `aPercentVolume` :  
        the percentage of the cylinder volume occupied by spheres  
    * `aUnitOfLength` :  
        the unit of length corresponding to aCylinderRadius, aCylinderHeight, and
        aSphereRadius. Acceptable values are: "um", "micrometre",
        "micrometer", "mm", "millimetre", "millimeter", "cm",
        "centimetre", "centimeter", "dm", "decimetre", "decimeter", "m",
        "metre", "meter", "dam", "decametre", "decameter", "hm",
        "hectometre", "hectometer", "km", "kilometre", "kilometer"
        (default value: "cm")  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    Returns
    -------
    the number of spheres  

    """
    return _temp_gvxrPython3.makeSpheresInCylinder(*args)

def addMesh(aDestination, aSource):
    r"""


    Add a polygon mesh (aSource) to another one (aDestination). It corresponds to
    the operation as follows: aDestination += aSource. Both aSource and aDestination
    have to already exist in the scenegraph.  

    Parameters
    ----------
    * `aDestination` :  
        the polygon mesh that is going to be modified  
    * `aSource` :  
        the polygon mesh that is going to be added to aDestination  

    """
    return _temp_gvxrPython3.addMesh(aDestination, aSource)

def subtractMesh(aDestination, aSource):
    r"""


    Subtract a polygon mesh (aSource) from another one (aDestination). It
    corresponds to the operation as follows: aDestination -= aSource. Both aSource
    and aDestination have to already exist in the scenegraph.  

    Parameters
    ----------
    * `aDestination` :  
        the polygon mesh that is going to be modified  
    * `aSource` :  
        the polygon mesh that is going to be subtracted from aDestination  

    """
    return _temp_gvxrPython3.subtractMesh(aDestination, aSource)

def getNumberOfChildren(aLabel):
    r"""


    Get the number of children of a node in the scenegraph.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the number of chidren  

    """
    return _temp_gvxrPython3.getNumberOfChildren(aLabel)

def getChildLabel(aLabel, i):
    r"""


    Accessor on the i-th child's label in the list of children of a given node in
    the scenegraph.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `i` :  
        the ID of the child  

    Returns
    -------
    the label corresponding to the i-th child  

    """
    return _temp_gvxrPython3.getChildLabel(aLabel, i)

def getLocalTransformationMatrix(aLabel):
    r"""


    Accessor on the local transformation matrix of a given node in the scenegraph.
    If the node does not exist, the identity matrix is returned.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the corresponding local transformation matrix  

    """
    return _temp_gvxrPython3.getLocalTransformationMatrix(aLabel)

def setLocalTransformationMatrix(aLabel, aMatrix):
    r"""


    Set the local transformation matrix of a given node in the scenegraph.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aMatrix` :  
        the local transformation matrix  

    """
    return _temp_gvxrPython3.setLocalTransformationMatrix(aLabel, aMatrix)

def applyCurrentLocalTransformation(aLabel):
    r"""


    Apply the current local transformation to all the vertices of a given node in
    the scenegraph. Note the the local transformation is then reset to the identity
    matrix.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    """
    return _temp_gvxrPython3.applyCurrentLocalTransformation(aLabel)

def getNodeAndChildrenBoundingBox(*args):
    r"""


    Access the bounding box of a given node and all its children (if any). The
    bounding box is given in the world coordinate system.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aUnitOfLength` :  
        the unit of length corresponding to the bounding box. Acceptable values are:
        "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer" (default value: "cm")  

    Returns
    -------
    the bounding box as: min_x, min_y, min_z, max_x, max_y, max_z  

    """
    return _temp_gvxrPython3.getNodeAndChildrenBoundingBox(*args)

def getNodeOnlyBoundingBox(*args):
    r"""


    Access the bounding box of a given node (without its children). The bounding box
    is given in the world coordinate system.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aUnitOfLength` :  
        the unit of length corresponding to the bounding box. Acceptable values are:
        "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer" (default value: "cm")  

    Returns
    -------
    the bounding box as: min_x, min_y, min_z, max_x, max_y, max_z  

    """
    return _temp_gvxrPython3.getNodeOnlyBoundingBox(*args)

def invertNormalVectors(aLabel):
    r"""


    Invert the normal vectors of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    """
    return _temp_gvxrPython3.invertNormalVectors(aLabel)

def hasNormalVectorsInverted(aLabel):
    r"""


    Check if the normal vectors have been inverted.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    true if the normal vectors have been inverted; false otherwise.  

    """
    return _temp_gvxrPython3.hasNormalVectorsInverted(aLabel)

def setColor(aLabel, R, G, B, A):
    r"""


    Set the color of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `R` :  
        the red channel  
    * `G` :  
        the green channel  
    * `B` :  
        the blue channel  
    * `A` :  
        the alpha channel  

    """
    return _temp_gvxrPython3.setColor(aLabel, R, G, B, A)

def setColour(aLabel, R, G, B, A):
    r"""


    Set the colour of a given polygon mesh. It will be applied to the ambiant,
    diffuse and specular colours.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `R` :  
        the red channel  
    * `G` :  
        the green channel  
    * `B` :  
        the blue channel  
    * `A` :  
        the alpha channel  

    """
    return _temp_gvxrPython3.setColour(aLabel, R, G, B, A)

def setAmbiantColour(aLabel, R, G, B, A):
    r"""


    Set the ambiant colour of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `R` :  
        the red channel  
    * `G` :  
        the green channel  
    * `B` :  
        the blue channel  
    * `A` :  
        the alpha channel  

    """
    return _temp_gvxrPython3.setAmbiantColour(aLabel, R, G, B, A)

def getAmbientColour(aLabel):
    r"""


    Accessor on the ambient colour of the material of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    the ambient colour  

    """
    return _temp_gvxrPython3.getAmbientColour(aLabel)

def setDiffuseColour(aLabel, R, G, B, A):
    r"""


    Set the diffuse colour of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `R` :  
        the red channel  
    * `G` :  
        the green channel  
    * `B` :  
        the blue channel  
    * `A` :  
        the alpha channel  

    """
    return _temp_gvxrPython3.setDiffuseColour(aLabel, R, G, B, A)

def getDiffuseColour(aLabel):
    r"""


    Accessor on the diffuse colour of the material of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    the diffuse colour  

    """
    return _temp_gvxrPython3.getDiffuseColour(aLabel)

def setSpecularColour(aLabel, R, G, B, A):
    r"""


    Set the specular colour of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `R` :  
        the red channel  
    * `G` :  
        the green channel  
    * `B` :  
        the blue channel  
    * `A` :  
        the alpha channel  

    """
    return _temp_gvxrPython3.setSpecularColour(aLabel, R, G, B, A)

def getSpecularColour(aLabel):
    r"""


    Accessor on the specular colour of the material of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    the specular colour  

    """
    return _temp_gvxrPython3.getSpecularColour(aLabel)

def setShininess(aLabel, aShininessValue):
    r"""


    Set the shininess of the material of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aShininessValue` :  
        the shininess coefficient  

    """
    return _temp_gvxrPython3.setShininess(aLabel, aShininessValue)

def getShininess(aLabel):
    r"""


    Accessor on the shininess of the material of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    the shininess coefficient  

    """
    return _temp_gvxrPython3.getShininess(aLabel)

def addPolygonMeshAsInnerSurface(aLabel):
    r"""


    Add a polygon mesh, given its label, to the X-ray renderer as an inner surface.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh in the scenegraph  

    """
    return _temp_gvxrPython3.addPolygonMeshAsInnerSurface(aLabel)

def addPolygonMeshAsOuterSurface(aLabel):
    r"""


    Add a polygon mesh, given its label, to the X-ray renderer as an outer surface.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh in the scenegraph  

    """
    return _temp_gvxrPython3.addPolygonMeshAsOuterSurface(aLabel)

def removePolygonMeshesFromSceneGraph():
    r"""


    Empty the scenegraph. Note that it also empties the X-ray renderer from all its
    meshes.  

    """
    return _temp_gvxrPython3.removePolygonMeshesFromSceneGraph()

def removePolygonMeshesFromXRayRenderer():
    r"""


    Empty the X-ray renderer from all its meshes. Note that the meshes are kept in
    the scenegraph.  

    """
    return _temp_gvxrPython3.removePolygonMeshesFromXRayRenderer()

def setSourcePosition(x, y, z, aUnitOfLength):
    r"""


    Set the position of the X-ray source.  

    Parameters
    ----------
    * `x` :  
        the position along the X-axis  
    * `y` :  
        the position along the Y-axis  
    * `z` :  
        the position along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the x, y and z parameters. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.setSourcePosition(x, y, z, aUnitOfLength)

def getSourceShape():
    r"""


    Accessor on the shape of the X-ray source.  

    """
    return _temp_gvxrPython3.getSourceShape()

def getSourcePosition(aUnitOfLength):
    r"""


    Accessor on the position of the X-ray source.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        the unit of length corresponding to the returned value. Acceptable values
        are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    Returns
    -------
    the source position in a given unit of length  

    """
    return _temp_gvxrPython3.getSourcePosition(aUnitOfLength)

def usePointSource():
    r"""


    Use a point source, i.e. a cone-beam geometry.  

    """
    return _temp_gvxrPython3.usePointSource()

def useConeBeam():
    r"""


    Use a cone-beam geometry, i.e. a point source.  

    """
    return _temp_gvxrPython3.useConeBeam()

def useParallelBeam():
    r"""


    Use a parallel source (e.g. to mimic a source that is extremely far from the
    scanned object and detector).  

    """
    return _temp_gvxrPython3.useParallelBeam()

def useParallelSource():
    r"""


    Use a parallel source (e.g. to mimic a source that is extremely far from the
    scanned object and detector).  

    """
    return _temp_gvxrPython3.useParallelSource()

def isUsingParallelBeam():
    r"""


    Check if the beam shape is parallel (e.g. to mimic a source that is extremely
    far from the scanned object and detector).  

    Returns
    -------
    true if the beam shape is parallel, false otherwise  

    """
    return _temp_gvxrPython3.isUsingParallelBeam()

def isUsingParallelSource():
    r"""


    Check if the beam shape is parallel (e.g. to mimic a source that is extremely
    far from the scanned object and detector).  

    Returns
    -------
    true if the beam shape is parallel, false otherwise  

    """
    return _temp_gvxrPython3.isUsingParallelSource()

def isUsingPointSource():
    r"""


    Check if the beam shape is cone-beam and the source an infinitively small point.  

    Returns
    -------
    true if an infinitively small point source is used, false otherwise  

    """
    return _temp_gvxrPython3.isUsingPointSource()

def isUsingConeBeam():
    r"""


    Check if the beam shape is cone-beam. Note that an infinitively small point
    source or a finite size focal spot may have been used.  

    Returns
    -------
    true if a cone-beam shape is used, false otherwise  

    """
    return _temp_gvxrPython3.isUsingConeBeam()

def isUsingFocalSpot():
    r"""


    Check if the beam shape is cone-beam and the source a finite size focal spot.  

    Returns
    -------
    true if a finite size focal spot is used, false otherwise  

    """
    return _temp_gvxrPython3.isUsingFocalSpot()

def setFocalSpot(x, y, z, l, aUnitOfLength, i):
    r"""


    Set the size of the focal spot of the X-ray generator. A cube shape is used. The
    volume of the cube is sampled by i^3 point sources.  

    Parameters
    ----------
    * `x` :  
        the position along the X-axis  
    * `y` :  
        the position along the Y-axis  
    * `z` :  
        the position along the Z-axis  
    * `l` :  
        the lenght of the cube along the 3 axes  
    * `aUnitOfLength` :  
        the unit of length. Acceptable values are: "um", "micrometre",
        "micrometer", "mm", "millimetre", "millimeter", "cm",
        "centimetre", "centimeter", "dm", "decimetre", "decimeter", "m",
        "metre", "meter", "dam", "decametre", "decameter", "hm",
        "hectometre", "hectometer", "km", "kilometre", "kilometer"  
    * `i` :  
        the number of point souces used along each axes.  

    """
    return _temp_gvxrPython3.setFocalSpot(x, y, z, l, aUnitOfLength, i)

def setFocalSpotAsSquare(x, y, z, l, aUnitOfLength, i):
    r"""


    Set the size of the focal spot of the X-ray generator. A square shape is used.
    The area of the square is sampled by i*i point sources.  

    Parameters
    ----------
    * `x` :  
        the position along the X-axis  
    * `y` :  
        the position along the Y-axis  
    * `z` :  
        the position along the Z-axis  
    * `l` :  
        the length of the square  
    * `aUnitOfLength` :  
        the unit of length. Acceptable values are: "um", "micrometre",
        "micrometer", "mm", "millimetre", "millimeter", "cm",
        "centimetre", "centimeter", "dm", "decimetre", "decimeter", "m",
        "metre", "meter", "dam", "decametre", "decameter", "hm",
        "hectometre", "hectometer", "km", "kilometre", "kilometer"  
    * `i` :  
        the number of point souces used along each axes.  

    """
    return _temp_gvxrPython3.setFocalSpotAsSquare(x, y, z, l, aUnitOfLength, i)

def setFocalSpotAsRectangle(x, y, z, l, k, aUnitOfLength, i, j):
    r"""


    Set the size of the focal spot of the X-ray generator. A rectangle shape is
    used. The area of the rectangle is sampled by i*j point sources.  

    Parameters
    ----------
    * `x` :  
        the position along the X-axis  
    * `y` :  
        the position along the Y-axis  
    * `z` :  
        the position along the Z-axis  
    * `l` :  
        the length of the rectangle along the axis defined by the cross product
        between the source-detector centres and the detector up-vector  
    * `k` :  
        the height of the source along the detector up-vector direction  
    * `aUnitOfLength` :  
        the unit of length. Acceptable values are: "um", "micrometre",
        "micrometer", "mm", "millimetre", "millimeter", "cm",
        "centimetre", "centimeter", "dm", "decimetre", "decimeter", "m",
        "metre", "meter", "dam", "decametre", "decameter", "hm",
        "hectometre", "hectometer", "km", "kilometre", "kilometer"  
    * `i` :  
        the number of point sources along the axis defined by the cross product
        between the source-detector centres and the detector up-vector.  
    * `j` :  
        the number of point sources along the detector up-vector direction.  

    """
    return _temp_gvxrPython3.setFocalSpotAsRectangle(x, y, z, l, k, aUnitOfLength, i, j)

def rotateFocalSpot(aRotationAngle, u, v, w):
    r"""


    Rotate the focal spot around its centre.  

    Parameters
    ----------
    * `aRotationAngle` :  
        the rotation angle in degrees  
    * `u` :  
        the rotaton axis along the X-axis  
    * `v` :  
        the rotaton axis along the Y-axis  
    * `w` :  
        the rotaton axis along the Z-axis  

    """
    return _temp_gvxrPython3.rotateFocalSpot(aRotationAngle, u, v, w)

def rotateSource(aRotationAngle, x, y, z, u, v, w):
    r"""


    Rotate the focal spot around an arbitrary point.  

    Parameters
    ----------
    * `aRotationAngle` :  
        the rotation angle in degrees  
    * `x` :  
        the rotaton centre along the X-axis  
    * `y` :  
        the rotaton centre along the Y-axis  
    * `z` :  
        the rotaton centre along the Z-axis  
    * `u` :  
        the rotaton axis along the X-axis  
    * `v` :  
        the rotaton axis along the Y-axis  
    * `w` :  
        the rotaton axis along the Z-axis  

    """
    return _temp_gvxrPython3.rotateSource(aRotationAngle, x, y, z, u, v, w)

def resetBeamSpectrum(aClearTubeParameterFlag=True):
    r"""


    Empty the beam spectrum.  

    Parameters
    ----------
    * `aClearTubeParameterFlag` :  
        if the flag is true, then the X-ray tubes parameters are reset too  

    """
    return _temp_gvxrPython3.resetBeamSpectrum(aClearTubeParameterFlag)

def setMonoChromatic(anEnergy, aUnitOfEnergy, aNumberOfPhotons):
    r"""


    Use a monochromatic beam spectrum (i.e. one single energy).  

    Parameters
    ----------
    * `anEnergy` :  
        the incident photon energy  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  
    * `aNumberOfPhotons` :  
        the number of incident photons  

    """
    return _temp_gvxrPython3.setMonoChromatic(anEnergy, aUnitOfEnergy, aNumberOfPhotons)

def addEnergyBinToSpectrum(anEnergy, aUnitOfEnergy, aNumberOfPhotons):
    r"""


    Add an energy bin to the beam spectrum (useful to generate polychromatism).  

    Parameters
    ----------
    * `anEnergy` :  
        the incident photon energy  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  
    * `aNumberOfPhotons` :  
        the number of incident photons  

    """
    return _temp_gvxrPython3.addEnergyBinToSpectrum(anEnergy, aUnitOfEnergy, aNumberOfPhotons)

def loadSpectrumFromTSV(aFileName, aUnitOfEnergy, aNormalisationFlag):
    r"""


    Load the incident beam energy spectrum from a TSV file.  

    Parameters
    ----------
    * `aFileName` :  
        name of the file to load  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  
    * `aNormalisationFlag` :  
        true to normalise the total energy to 1, false otherwise  

    """
    return _temp_gvxrPython3.loadSpectrumFromTSV(aFileName, aUnitOfEnergy, aNormalisationFlag)

def getEnergyBins(aUnitOfEnergy):
    r"""


    Accessor on the energy bins of the beam spectrum.  

    Parameters
    ----------
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to the returned vector. Acceptable values
        are: "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the list of energy bins in aUnitOfEnergy  

    """
    return _temp_gvxrPython3.getEnergyBins(aUnitOfEnergy)

def getPhotonCountEnergyBins():
    r"""


    Accessor on the number of photons per energy bin of the beam spectrum.  

    Returns
    -------
    the list of number of photons  

    """
    return _temp_gvxrPython3.getPhotonCountEnergyBins()

def getTotalEnergyWithDetectorResponse():
    r"""


    Accessor on a total energy of the beam when the detector response is applied.  

    Returns
    -------
    the total energy  

    """
    return _temp_gvxrPython3.getTotalEnergyWithDetectorResponse()

def setVoltage(aVoltage, aUnitOfElectriPotential):
    r"""


    Set the voltage of the X-ray tube.  

    Parameters
    ----------
    * `aVoltage` :  
        the voltage  
    * `aUnitOfElectriPotential` :  
        the unit of electric potential to the voltage of the tube. Acceptable values
        are: "megavolt", "MV", "kilovolt", "kV", "volt", "V"  

    """
    return _temp_gvxrPython3.setVoltage(aVoltage, aUnitOfElectriPotential)

def getVoltage(aUnitOfElectriPotential):
    r"""


    Accessor on the voltage of the X-ray tube.  

    Parameters
    ----------
    * `aUnitOfElectriPotential` :  
        the unit of electric potential to the voltage of the tube. Acceptable values
        are: "megavolt", "MV", "kilovolt", "kV", "volt", "V"  

    Returns
    -------
    the voltage of the X-ray tube  

    """
    return _temp_gvxrPython3.getVoltage(aUnitOfElectriPotential)

def setmAs(an_mAs):
    r"""


    Set the exposure in milliampere second (mA⋅s).  

    Parameters
    ----------
    * `an_mAs` :  
        the exposure  

    """
    return _temp_gvxrPython3.setmAs(an_mAs)

def getmAs():
    r"""


    Accessor on the exposure in milliampere second (mA⋅s).  

    Returns
    -------
    the exposure  

    """
    return _temp_gvxrPython3.getmAs()

def setTubeAngle(anAngle):
    r"""


    Set the angle of the X-ray tube (i.e. its anode's target) in degrees.  

    Parameters
    ----------
    * `anAngle` :  
        the angle  

    """
    return _temp_gvxrPython3.setTubeAngle(anAngle)

def getTubeAngle():
    r"""


    Accessor on the angle of the X-ray tube (i.e. its anode's target) in degrees.  

    Returns
    -------
    the angle  

    """
    return _temp_gvxrPython3.getTubeAngle()

def clearFiltration():
    r"""


    If the beam is filtered, remove all the filtration.  

    """
    return _temp_gvxrPython3.clearFiltration()

def setFiltration(aSetOfFilters, aUnitOfLength):
    r"""


    Set the beam filtration.  

    Parameters
    ----------
    * `aSetOfFilters` :  
        the set of filter. In the C++ notation, it is a vector of pairs of unsigned
        int and float. Each unsigned int value corresponds to the Z number of the
        material of the filter; and each float value corresponds to the thickness of
        the filter. Several filters can be used.  
    * `aUnitOfLength` :  
        the unit of length. Acceptable values are: "um", "micrometre",
        "micrometer", "mm", "millimetre", "millimeter", "cm",
        "centimetre", "centimeter", "dm", "decimetre", "decimeter", "m",
        "metre", "meter", "dam", "decametre", "decameter", "hm",
        "hectometre", "hectometer", "km", "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.setFiltration(aSetOfFilters, aUnitOfLength)

def addFilter(*args):
    r"""


    Add a filter.  

    Parameters
    ----------
    * `aMaterial` :  
        The Z number of the material of the filter  
    * `aThickness` :  
        The thickness of the filter  
    * `aUnitOfLength` :  
        the unit of length. Acceptable values are: "um", "micrometre",
        "micrometer", "mm", "millimetre", "millimeter", "cm",
        "centimetre", "centimeter", "dm", "decimetre", "decimeter", "m",
        "metre", "meter", "dam", "decametre", "decameter", "hm",
        "hectometre", "hectometer", "km", "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.addFilter(*args)

def getFiltrationMaterial():
    r"""


    Accessor on all the materials (Z numbers) of all the beam filters used.  

    Returns
    -------
    the Z numbers corresponding to the beam filters used. If none is used, an empty
    array is returned.  

    """
    return _temp_gvxrPython3.getFiltrationMaterial()

def getFiltrationThickness(aUnitOfLength):
    r"""


    Accessor on all the thickness of all the beam filters used.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        the unit of length corresponding to the thicknesses. Acceptable values are:
        "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    Returns
    -------
    the thickness of all the beam filters used. If none is used, an empty array is
    returned.  

    """
    return _temp_gvxrPython3.getFiltrationThickness(aUnitOfLength)

def hasSpekpy():
    r"""


    Check if the Spekpy backend is available internally.  

    Returns
    -------
    true if the Spekpy backend is available, otherwise false  

    """
    return _temp_gvxrPython3.hasSpekpy()

def hasXpecgen():
    r"""


    Check if the Xpecgen backend is available internally.  

    Returns
    -------
    true if the Xpecgen backend is available, otherwise false  

    """
    return _temp_gvxrPython3.hasXpecgen()

def useSpekpy():
    r"""


    Use Spekpy internally if possible.  

    """
    return _temp_gvxrPython3.useSpekpy()

def useXpecgen():
    r"""


    Use Xpecgen internally if possible.  

    """
    return _temp_gvxrPython3.useXpecgen()

def usingSpekpy():
    r"""


    Check if the Spekpy backend is being used internally.  

    Returns
    -------
    true if the Spekpy backend is being used, otherwise false  

    """
    return _temp_gvxrPython3.usingSpekpy()

def usingXpecgen():
    r"""


    Check if the Xpecgen backend is being used internally.  

    Returns
    -------
    true if the Xpecgen backend is being used, otherwise false  

    """
    return _temp_gvxrPython3.usingXpecgen()

def enablePoissonNoise():
    r"""


    Enable Poisson noise for the energy fluence.  

    """
    return _temp_gvxrPython3.enablePoissonNoise()

def disablePoissonNoise():
    r"""


    Disable Poisson noise for the energy fluence.  

    """
    return _temp_gvxrPython3.disablePoissonNoise()

def setNumberOfPhotons(aNumberOfPhotons):
    r"""


    Set the total number of photons per pixel.  

    Parameters
    ----------
    * `aNumberOfPhotons` :  
        the number of photons  

    """
    return _temp_gvxrPython3.setNumberOfPhotons(aNumberOfPhotons)

def setNumberOfPhotonsPerPixel(aNumberOfPhotons):
    r"""


    Set the total number of photons per pixel.  

    Parameters
    ----------
    * `aNumberOfPhotons` :  
        the number of photons  

    """
    return _temp_gvxrPython3.setNumberOfPhotonsPerPixel(aNumberOfPhotons)

def setNumberOfPhotonsPerCM2(aNumberOfPhotons):
    r"""


    Set the total number of photons per square centimetre.  

    Parameters
    ----------
    * `aNumberOfPhotons` :  
        the number of photons  

    """
    return _temp_gvxrPython3.setNumberOfPhotonsPerCM2(aNumberOfPhotons)

def getNumberOfPhotons():
    r"""


    Accessor on the total number of photons per pixel.  

    Returns
    -------
    the number of photons  

    """
    return _temp_gvxrPython3.getNumberOfPhotons()

def getNumberOfPhotonsPerPixel():
    r"""


    Accessor on the total number of photons per pixel.  

    Returns
    -------
    the number of photons  

    """
    return _temp_gvxrPython3.getNumberOfPhotonsPerPixel()

def getNumberOfPhotonsPerCM2():
    r"""


    Accessor on the total number of photons per square centimetre.  

    Returns
    -------
    the number of photons  

    """
    return _temp_gvxrPython3.getNumberOfPhotonsPerCM2()

def usePoissonNoise(*args):
    r"""


    Check if Poisson noise for the energy fluence is enable or disable.  

    Returns
    -------
    true if Poisson noise is enable, or false if Poisson noise is disable  

    """
    return _temp_gvxrPython3.usePoissonNoise(*args)

def radian2degree(anAngle):
    r"""


    Convert an angle given in radians into degrees.  

    Parameters
    ----------
    * `anAngle` :  
        the angle in radians  

    Returns
    -------
    the corresponding angle in degrees  

    """
    return _temp_gvxrPython3.radian2degree(anAngle)

def getUnitOfEnergy(aUnitOfEnergy):
    r"""


    Accessor on the numerical value corresponding to a unit of energy.  

    Parameters
    ----------
    * `aUnitOfEnergy` :  
        the unit of energy. Acceptable values are: "electronvolt", "eV",
        "kiloelectronvolt", "keV", "megaelectronvolt", "MeV"  

    Returns
    -------
    the corresponding numerical value  

    """
    return _temp_gvxrPython3.getUnitOfEnergy(aUnitOfEnergy)

def getUnitOfLength(aUnitOfLength):
    r"""


    Accessor on the numerical value corresponding to a unit of length.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        the unit of length. Acceptable values are: "um", "micrometre",
        "micrometer", "mm", "millimetre", "millimeter", "cm",
        "centimetre", "centimeter", "dm", "decimetre", "decimeter", "m",
        "metre", "meter", "dam", "decametre", "decameter", "hm",
        "hectometre", "hectometer", "km", "kilometre", "kilometer"  

    Returns
    -------
    the corresponding numerical value  

    """
    return _temp_gvxrPython3.getUnitOfLength(aUnitOfLength)

def getUnitOfElectriPotential(aUnitOfElectriPotential):
    r"""


    Accessor on the numerical value corresponding to a unit of electric potential.  

    Parameters
    ----------
    * `aUnitOfElectriPotential` :  
        the unit of electric potential. Acceptable values are: "V", "volt",
        "kV", "kilovolt", "MV", "megavolt"  

    Returns
    -------
    the corresponding numerical value  

    """
    return _temp_gvxrPython3.getUnitOfElectriPotential(aUnitOfElectriPotential)

def enableArtefactFilteringOnGPU():
    r"""


    Enable artefact filtering on GPU (it is fast but can be inaccurate).  

    """
    return _temp_gvxrPython3.enableArtefactFilteringOnGPU()

def enableArtifactFilteringOnGPU():
    r"""


    Enable artefact filtering on GPU (it is fast but can be inaccurate).  

    """
    return _temp_gvxrPython3.enableArtifactFilteringOnGPU()

def enableArtefactFilteringOnCPU():
    r"""


    Enable artefact filtering on CPU (can be extremely slow as it makes use of ray-
    tracing).  

    """
    return _temp_gvxrPython3.enableArtefactFilteringOnCPU()

def enableArtifactFilteringOnCPU():
    r"""


    Enable artefact filtering on CPU (can be extremely slow as it makes use of ray-
    tracing).  

    """
    return _temp_gvxrPython3.enableArtifactFilteringOnCPU()

def disableArtefactFiltering():
    r"""


    Disable artefact filtering altogether.  

    """
    return _temp_gvxrPython3.disableArtefactFiltering()

def disableArtifactFiltering():
    r"""


    Disable artefact filtering altogether.  

    """
    return _temp_gvxrPython3.disableArtifactFiltering()

def getNumberOfEGLDevices():
    r"""


    Accessor on the number of EGL devices.  

    """
    return _temp_gvxrPython3.getNumberOfEGLDevices()

def findEGLClients():
    r"""


    Accessor on the list of supported EGL clients.  

    """
    return _temp_gvxrPython3.findEGLClients()

def createOpenGLContext(aWindowID=-1, aRendererMajorVersion=4, aRendererMinorVersion=3):
    r"""


    Create an OpenGL context (the window won't be shown).  

    Parameters
    ----------
    * `aWindowID` :  
        the numerical ID of the context to create (default value: -1, means that the
        ID will be automatically generated)  
    * `aRendererMajorVersion` :  
        Select the major version of the renderer. (default value: 4)  
    * `aRendererMinorVersion` :  
        Select the minor version of the renderer. (default value: 3)  

    """
    return _temp_gvxrPython3.createOpenGLContext(aWindowID, aRendererMajorVersion, aRendererMinorVersion)

def createWindow(*args):
    r"""


    Create an OpenGL context and display it in a window.  

    Parameters
    ----------
    * `aWindowID` :  
        the numerical ID of the context to create (default value: -1, means that the
        ID will be automatically generated)  
    * `aRenderer` :  
        Select the renderer to use, e.g. OpenGL or Vulkan. (default value: OPENGL)  
    * `aRendererMajorVersion` :  
        Select the major version of the renderer. (default value: 4)  
    * `aRendererMinorVersion` :  
        Select the minor version of the renderer. (default value: 3)  
    * `aVisibilityFlag` :  
        flag controling if the window should be visible (1) or hidden (0). (default
        value: 0)  

    """
    return _temp_gvxrPython3.createWindow(*args)

def createNewContext(*args):
    r"""


    Create an OpenGL context.  

    Parameters
    ----------
    * `aRenderer` :  
        Select the renderer to use, e.g. OpenGL or Vulkan. (default value: OPENGL)  
    * `aWindowID` :  
        the numerical ID of the context to create (default value: -1, means that the
        ID will be automatically generated)  
    * `aRendererMajorVersion` :  
        Select the major version of the renderer. (default value: 4)  
    * `aRendererMinorVersion` :  
        Select the minor version of the renderer. (default value: 3S)  
    * `aVisibilityFlag` :  
        flag controling if the window should be visible (1) or hidden (0). (default
        value: 0)  

    """
    return _temp_gvxrPython3.createNewContext(*args)

def setWindowSize(aWidth, aHeight, aWindowID=-1):
    r"""


    Set the size of the given window.  

    Parameters
    ----------
    * `aWidth` :  
        the number of pixels along the X-axis  
    * `aHeight` :  
        the number of pixels along the Y-axis  
    * `aWindowID` :  
        the numerical ID of the corresponding context (default value: -1, means that
        the active context will be used)  

    """
    return _temp_gvxrPython3.setWindowSize(aWidth, aHeight, aWindowID)

def getWindowSize(aWindowID=-1):
    r"""


    Accessor on the size of a given window.  

    Returns
    -------
    the size of the window  

    """
    return _temp_gvxrPython3.getWindowSize(aWindowID)

def destroyWindow(aWindowID=-1):
    r"""


    Close and destroy a given window or OpenGL context.  

    """
    return _temp_gvxrPython3.destroyWindow(aWindowID)

def destroyAllWindows():
    r"""


    Close and destroy all the windows and OpenGL contexts that have been created.
    Same as void terminate(void);.  

    """
    return _temp_gvxrPython3.destroyAllWindows()

def destroy():
    r"""


    Close and destroy all the windows and OpenGL contexts that have been created. It
    also releases all the graphics memory.  

    """
    return _temp_gvxrPython3.destroy()

def terminate():
    r"""


    Close and destroy all the windows and OpenGL contexts that have been created. It
    also releases all the graphics memory. Note: it'll be deprecated in a future
    version og gVXR. Use void destroy(void) instead.  

    """
    return _temp_gvxrPython3.terminate()

def displayBeam(aState=True):
    r"""


    Display/Hide the beam in the 3D visualisation.  

    Parameters
    ----------
    * `aState` :  
        if true the beam will be displayed, otherwise it won't be (default value:
        true)  

    """
    return _temp_gvxrPython3.displayBeam(aState)

def displayDetector(aState=True):
    r"""


    Display/Hide the detector in the 3D visualisation.  

    Parameters
    ----------
    * `aState` :  
        if true the detector will be displayed, otherwise it won't be (default
        value: true)  

    """
    return _temp_gvxrPython3.displayDetector(aState)

def displayNormalVectors(aState=True):
    r"""


    Display/Hide the normal vectors of the sample in the 3D visualisation.  

    Parameters
    ----------
    * `aState` :  
        if true the normal vectors will be displayed, otherwise they won't be
        (default value: true)  

    """
    return _temp_gvxrPython3.displayNormalVectors(aState)

def useWireframe(aState=True):
    r"""


    Use/Don't use wireframe rendering in the 3D visualisation.  

    Parameters
    ----------
    * `aState` :  
        if true the sample will be displayed in wireframe, otherwise it'll be solid
        (default value: true)  

    """
    return _temp_gvxrPython3.useWireframe(aState)

def useLighing(aState=True):
    r"""


    Use/Don't lighting in the 3D visualisation.  

    Parameters
    ----------
    * `aState` :  
        if true lighting will be on, otherwise it'll be off (default value: true)  

    """
    return _temp_gvxrPython3.useLighing(aState)

def useNegative(aState=True):
    r"""


    Use/Don't a negative LUT to show the X-ray projection in the 3D visualisation.  

    Parameters
    ----------
    * `aState` :  
        if true the X-ray projection will be shown in negative, otherwise in
        positive (default value: true)  

    """
    return _temp_gvxrPython3.useNegative(aState)

def setAxisLength(aLength, aUnitOfLength):
    r"""


    Set the size of the axis widget in the 3D visualisation.  

    Parameters
    ----------
    * `aLength` :  
        Size of the axis widget  
    * `aUnitOfLength` :  
        the unit of length corresponding to aLength. Acceptable values are: "um",
        "micrometre", "micrometer", "mm", "millimetre", "millimeter",
        "cm", "centimetre", "centimeter", "dm", "decimetre",
        "decimeter", "m", "metre", "meter", "dam", "decametre",
        "decameter", "hm", "hectometre", "hectometer", "km",
        "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.setAxisLength(aLength, aUnitOfLength)

def setMarkerLength(aLength, aUnitOfLength):
    r"""


    Set the size of the marker widgets in the 3D visualisation.  

    Parameters
    ----------
    * `aLength` :  
        Size of the marker widgets  
    * `aUnitOfLength` :  
        the unit of length corresponding to aLength. Acceptable values are: "um",
        "micrometre", "micrometer", "mm", "millimetre", "millimeter",
        "cm", "centimetre", "centimeter", "dm", "decimetre",
        "decimeter", "m", "metre", "meter", "dam", "decametre",
        "decameter", "hm", "hectometre", "hectometer", "km",
        "kilometre", "kilometer"  

    """
    return _temp_gvxrPython3.setMarkerLength(aLength, aUnitOfLength)

def orthographic(left, right, bottom, top, zNear, zFar):
    r"""


    Replace the projection matrix by a orthographic projection matrix. It behaves as
    the old glOrtho function.  

    Parameters
    ----------
    * `left` :  
        Specify the coordinates for the left vertical clipping plane  
    * `right` :  
        Specify the coordinates for the right vertical clipping plane  
    * `bottom` :  
        Specify the coordinates for the bottom horizontal clipping plane  
    * `top` :  
        Specify the coordinates for the top horizontal clipping plane  
    * `zNear` :  
        Specify the distances to the near clipping plane. The value must be positive  
    * `zFar` :  
        Specify the distances to the far clipping plane. The value must be positive  

    """
    return _temp_gvxrPython3.orthographic(left, right, bottom, top, zNear, zFar)

def perspective(fovy, aspect, zNear, zFar):
    r"""


    Replace the projection matrix by a perspective projection matrix. It behaves as
    the old gluPerspective function.  

    Parameters
    ----------
    * `fovy` :  
        specifies the field of view angle, in degrees, in the y-direction.  
    * `aspect` :  
        Specifies the aspect ratio that determines the field of view in the x
        direction. The aspect ratio is the ratio of x (width) to y (height).  
    * `zNear` :  
        Specifies the distance from the viewer to the near clipping plane (always
        positive)  
    * `zFar` :  
        Specifies the distance from the viewer to the far clipping plane (always
        positive).  

    """
    return _temp_gvxrPython3.perspective(fovy, aspect, zNear, zFar)

def lookAt(eyeX, eyeY, eyeZ, lookAtX, lookAtY, lookAtZ, upX, upY, upZ):
    r"""


    Replace the modelling-viewing matrix by a viewing transformation matrix. It
    behaves as the old gluLookAt function.  

    Parameters
    ----------
    * `eyeX` :  
        Specifies the position of the eye point along the X-axis  
    * `eyeY` :  
        Specifies the position of the eye point along the Y-axis  
    * `eyeZ` :  
        Specifies the position of the eye point along the Z-axis  
    * `lookAtX` :  
        Specifies the position of the reference point along the X-axis  
    * `lookAtY` :  
        Specifies the position of the reference point along the Y-axis  
    * `lookAtZ` :  
        Specifies the position of the reference point along the Z-axis  
    * `upX` :  
        Specifies the direction of the up vector along the X-axis  
    * `upY` :  
        Specifies the direction of the up vector along the Y-axis  
    * `upZ` :  
        Specifies the direction of the up vector along the Z-axis  

    """
    return _temp_gvxrPython3.lookAt(eyeX, eyeY, eyeZ, lookAtX, lookAtY, lookAtZ, upX, upY, upZ)

def pushModelViewMatrix():
    r"""


    Add the current matrix to the model/view matrix stack. It behaves as the
    combination of the old glMatrixMode(GL_MODELVIEW);glPushMatrix() functions.  

    """
    return _temp_gvxrPython3.pushModelViewMatrix()

def popModelViewMatrix():
    r"""


    Restore the matrix from the model/view matrix stack, and remove the last matrix
    of the stack. glMatrixMode(GL_MODELVIEW);glPopMatrix() functions.  

    """
    return _temp_gvxrPython3.popModelViewMatrix()

def rotateModelView(anAngle, x, y, z):
    r"""


    Restore the matrix from the model/view matrix stack, and remove the last matrix
    of the stack. glMatrixMode(GL_MODELVIEW);glRotate() functions.  

    Parameters
    ----------
    * `anAngle` :  
        the angle of rotation in degrees  
    * `x` :  
        the coordinate of the rotation axis along the X-axis  
    * `y` :  
        the coordinate of the rotation axis along the Y-axis  
    * `z` :  
        the coordinate of the rotation axis along the Z-axis  

    """
    return _temp_gvxrPython3.rotateModelView(anAngle, x, y, z)


