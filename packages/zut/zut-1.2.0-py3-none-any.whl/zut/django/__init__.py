import os
import re
from ctypes.util import find_library
from datetime import date, datetime
from decimal import Decimal
from pathlib import Path

from django.conf import settings
from django.conf.urls.static import static as static_urls
from django.db import models
from django.db.models import Field, Model, UniqueConstraint
from django.http import HttpRequest
from django.templatetags.static import static as static_tags
from django.urls import include, path
from django.views.generic import RedirectView
from django.views.generic.base import RedirectView


#region Models and fields

def get_field_python_type(field: Field) -> type|None:
    if isinstance(field, models.BooleanField):
        return bool
    elif isinstance(field, models.IntegerField):
        return int
    elif isinstance(field, models.FloatField):
        return float
    elif isinstance(field, models.DecimalField):
        return Decimal
    elif isinstance(field, models.DateTimeField):
        return datetime
    elif isinstance(field, models.DateField):
        return date
    elif isinstance(field, models.CharField):
        return str
    elif isinstance(field, models.TextField):
        return str
    else:
        return None # we don't want to make false assumptions (e.g. we would probably want 'str' in the context of a load table and 'int' for a foreign key field)


def get_model_unique_keys(model: Model) -> list[tuple[str]]:
    """
    Report django model unique keys, based on attnames (column names).
    """
    field_orders: dict[str,int] = {}
    attnames_by_name: dict[str,str] = {}

    class Unique:
        def __init__(self, fields: list[str]|tuple[str]|str):
            if isinstance(fields, str):
                self.fields = [fields]
            elif isinstance(fields, (list,tuple)):
                self.fields: list[str] = []
                for i, name in enumerate(fields):
                    if isinstance(name, str):
                        if not name in field_orders:
                            name = attnames_by_name[name]
                        self.fields.append(name)
                    else:
                        raise TypeError(f"fields[{i}]: {type(name).__name__}")  
            else:
                raise TypeError(f"fields: {type(fields).__name__}")            
            
            self.min_field_order = min(field_orders[field] for field in self.fields)

        def append(self, field: str):
            self.fields.append(field)
            if field_orders[field] < self.min_field_order:
                self.min_field_order = field_orders[field]

    primary_key: Unique = None
    other_keys: list[Unique] = []


    field: Field
    for i, field in enumerate(model._meta.fields):
        field_orders[field.attname] = i
        attnames_by_name[field.name] = field.attname
        
        if field.primary_key:
            if not primary_key:
                primary_key = Unique(field.attname)
            else:
                primary_key.append(field.attname)
        elif field.unique:
            other_keys.append(Unique(field.attname))

    for names in model._meta.unique_together:
        other_keys.append(Unique(names))

    for constraint in model._meta.constraints:
        if isinstance(constraint, UniqueConstraint):
            other_keys.append(Unique(constraint.fields))

    results = []
    
    if primary_key:
        results.append(tuple(primary_key.fields))

    for key in sorted(other_keys, key=lambda key: key.min_field_order):
        results.append(tuple(key.fields))

    return results


class TriggerCharField(models.CharField):
    """
    Mark a char field generated by a database trigger.

    - `db_returning = True` ensures that the model instance is updated after save() with the value computed by the database trigger.
    """
    db_returning = True
    editable = False

    def formfield(self, **kwargs):
        return None

#endregion


#region Requests

def get_request_ip_address(request: HttpRequest):
    """
    Get the client IP address.

    Make sure you have reverse proxy (if any) configured correctly (e.g. mod_rpaf installed for Apache).

    See: https://stackoverflow.com/a/4581997
    """
    if request is None:
        return '127.0.0.1'
    
    x_forwarded_for: str = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        return x_forwarded_for.split(',')[0]
    else:
        return request.META.get('REMOTE_ADDR')


def get_request_country_code(request: HttpRequest):
    """
    Guess the client country code, from its IP address, or from its Accept-Language header.

    Requires geoip2.
    """
    from django.contrib.gis.geoip2 import GeoIP2
    from geoip2.errors import AddressNotFoundError

    g = GeoIP2()
    try:
        result = g.country(get_request_ip_address(request))
        return result['country_code']
    except AddressNotFoundError:
        pass

    if 'Accept-Language' in request.headers:
        selected_country_code = None
        selected_priority = None
        for lang in request.headers['Accept-Language'].split(','):
            m = re.match(r'^[a-z]{2}\-([A-Z]{2})(?:;q=([0-9\.]+))?$', lang, re.IGNORECASE)
            if m:
                country_code = m[1].upper()
                priority = float(m[2] or 1)
                if selected_priority is None or priority > selected_priority:
                    selected_country_code = country_code
                    selected_priority = priority

        return selected_country_code

#endregion


#region URLs

def websocket_include(arg, namespace):
    urlconf_module, app_name, namespace = include(arg, namespace)
    websocket_urlpatterns = getattr(urlconf_module, 'websocket_urlpatterns', [])
    return websocket_urlpatterns, app_name, namespace


def static_urlpatterns(favicon_url: str = None):
    """
    Serve static and media directory (and favicon for reused apps that do not have one, e.g. admin app) in development (in production, this should be served by the frontend web server).
    """
    urlpatterns = []

    if favicon_url:
        urlpatterns += [path('favicon.ico', RedirectView.as_view(url=static_tags(favicon_url)))]

    if settings.MEDIA_URL != '/' and settings.MEDIA_ROOT:
        urlpatterns += static_urls(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

    if not settings.DEBUG:
        if settings.STATIC_URL != '/' and settings.STATIC_URL:
            urlpatterns += static_urls(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

    return urlpatterns

#endregion
