use pyo3::exceptions::{PyKeyError, PyValueError};
use pyo3::prelude::*;
use pyo3::types::{PyDict, PyList};
use tdigests::{Centroid, TDigest};

#[pyclass(name = "TDigest", module = "fastdigest")]
struct PyTDigest {
    digest: TDigest,
}

#[pymethods]
impl PyTDigest {
    /// Constructs a new TDigest from a non‑empty list of float values.
    #[new]
    pub fn new(values: Vec<f64>) -> PyResult<Self> {
        if values.is_empty() {
            Err(PyValueError::new_err("Values list cannot be empty"))
        } else {
            Ok(Self {
                digest: TDigest::from_values(values),
            })
        }
    }

    /// Estimates the quantile for a given cumulative probability `q`.
    pub fn estimate_quantile(&self, q: f64) -> PyResult<f64> {
        if q < 0.0 || q > 1.0 {
            return Err(PyValueError::new_err("q must be between 0 and 1."));
        }
        Ok(self.digest.estimate_quantile(q))
    }

    /// Estimates the rank (cumulative probability) of a given value `x`.
    pub fn estimate_rank(&self, x: f64) -> PyResult<f64> {
        Ok(self.digest.estimate_rank(x))
    }

    /// Merges this digest with another, returning a new TDigest.
    pub fn merge(&self, other: &Self) -> PyResult<Self> {
        Ok(Self {
            digest: self.digest.merge(&other.digest),
        })
    }

    /// Compresses the digest (in‑place) to have at most `max_centroids`
    /// (but at least `min(n_values, 3)`) centroids.
    pub fn compress(&mut self, max_centroids: usize) {
        self.digest.compress(max_centroids);
    }

    /// Returns the trimmed mean of the digest between the q1 and q2 quantiles.
    pub fn trimmed_mean(&self, q1: f64, q2: f64) -> PyResult<f64> {
        if q1 < 0.0 || q2 > 1.0 || q1 >= q2 {
            return Err(PyValueError::new_err(
                "q1 must be >= 0, q2 must be <= 1, and q1 < q2",
            ));
        }

        let centroids = self.digest.centroids();
        let total_weight: f64 = centroids.iter().map(|c| c.weight).sum();
        if total_weight == 0.0 {
            return Err(PyValueError::new_err("Total weight is zero"));
        }
        let lower_weight_threshold = q1 * total_weight;
        let upper_weight_threshold = q2 * total_weight;

        let mut cum_weight = 0.0;
        let mut trimmed_sum = 0.0;
        let mut trimmed_weight = 0.0;
        for centroid in centroids {
            let c_start = cum_weight;
            let c_end = cum_weight + centroid.weight;
            cum_weight = c_end;

            if c_end <= lower_weight_threshold {
                continue;
            }
            if c_start >= upper_weight_threshold {
                break;
            }

            let overlap = (c_end.min(upper_weight_threshold)
                - c_start.max(lower_weight_threshold))
            .max(0.0);
            trimmed_sum += overlap * centroid.mean;
            trimmed_weight += overlap;
        }

        if trimmed_weight == 0.0 {
            return Err(PyValueError::new_err("No data in the trimmed range"));
        }
        Ok(trimmed_sum / trimmed_weight)
    }

    /// Returns a dictionary representation of the digest.
    ///
    /// The dictionary contains a key "centroids" mapping to a list of dictionaries,
    /// each with keys "m" (mean) and "c" (weight or count).
    pub fn to_dict(&self, py: Python) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        let centroid_list = PyList::empty(py);
        for centroid in self.digest.centroids() {
            let centroid_dict = PyDict::new(py);
            centroid_dict.set_item("m", centroid.mean)?;
            centroid_dict.set_item("c", centroid.weight)?;
            centroid_list.append(centroid_dict)?;
        }
        dict.set_item("centroids", centroid_list)?;
        Ok(dict.into_any().unbind())
    }

    /// Reconstructs a TDigest from a dictionary.
    /// A dict generated by the "tdigest" Python library will work out of the box.
    #[staticmethod]
    pub fn from_dict<'py>(
        tdigest_dict: &Bound<'py, PyDict>,
    ) -> PyResult<Self> {
        let centroids_obj =
            tdigest_dict.get_item("centroids")?.ok_or_else(|| {
                PyKeyError::new_err("Key 'centroids' not found in dictionary")
            })?;
        let centroids_list: &Bound<'py, PyList> = centroids_obj.downcast()?;
        let mut centroids = Vec::with_capacity(centroids_list.len());
        for item in centroids_list.iter() {
            let d: &Bound<'py, PyDict> = item.downcast()?;
            let mean: f64 = d
                .get_item("m")?
                .ok_or_else(|| {
                    PyKeyError::new_err("Centroid missing 'm' key")
                })?
                .extract()?;
            let weight: f64 = d
                .get_item("c")?
                .ok_or_else(|| {
                    PyKeyError::new_err("Centroid missing 'c' key")
                })?
                .extract()?;
            centroids.push(Centroid::new(mean, weight));
        }
        if centroids.is_empty() {
            return Err(PyValueError::new_err(
                "Centroids list cannot be empty",
            ));
        }
        Ok(Self {
            digest: TDigest::from_centroids(centroids),
        })
    }

    /// Getter property: returns the total number of data points ingested.
    #[getter(n_values)]
    pub fn get_n_values(&self) -> PyResult<u64> {
        let total_weight: f64 =
            self.digest.centroids().iter().map(|c| c.weight).sum();
        Ok(total_weight.round() as u64)
    }

    /// Getter property: returns the number of centroids.
    #[getter(n_centroids)]
    pub fn get_n_centroids(&self) -> PyResult<usize> {
        Ok(self.digest.centroids().len())
    }

    /// Magic method: len(TDigest) returns the number of centroids.
    pub fn __len__(&self) -> PyResult<usize> {
        self.get_n_centroids()
    }

    /// Magic method: repr(TDigest)/str(TDigest) returns a string representation.
    fn __repr__(&self) -> PyResult<String> {
        Ok(format!(
            "TDigest(n_values={}, n_centroids={})",
            self.get_n_values()?,
            self.get_n_centroids()?
        ))
    }
}

/// The Python module definition.
#[pymodule]
fn fastdigest(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<PyTDigest>()?;
    Ok(())
}
