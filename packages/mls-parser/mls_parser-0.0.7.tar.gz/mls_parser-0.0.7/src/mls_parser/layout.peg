// Flatland Model Layout Arpeggio Clean Peg Grammar

// This grammar expresses the geometric layout of nodes and connectors and where
// connectors attach to node faces on a diagram. It does not specify any meaning
// associated with the nodes and connectors. Node and connector names are ascribed
// in their model files, but no other information in the model files is referenced
// in this grammar.

// You can draw unconnected nodes, connected nodes or a blank sheet
diagram_layout = EOL* layout_spec ((node_block connector_block) / (node_block))? EOF

// Layout spec
layout_spec = (diagram notation color? presentation sheet padding? orientation frame? frame_presentation?)# // Each of these in any order

// Diagram
diagram = "diagram" SP+ name EOL* // The type of diagram to draw
notation =  "notation" SP+ name EOL* // The notation to use in the diagram
color = "color" SP+ name EOL* // The type of diagram to draw
presentation = "presentation" SP+ name EOL* // The presentation style for drawing
sheet = "sheet" SP+ name EOL* // The sheet size name
padding = "padding" (tpad? bpad? lpad? rpad?)# EOL*
tpad = SP+ 't'number
bpad = SP+ 'b'number
lpad = SP+ 'l'number
rpad = SP+ 'r'number
orientation = "orientation" SP+ ("portrait" / "landscape") EOL* // The sheet orientation
frame = "frame" SP+ name EOL* // The frame name
frame_presentation = "frame_presentation" SP+ name EOL* // The presentation style for the frame

// Node
node_block = nodes_header node_spec+
nodes_header = "nodes" EOL*
node_spec = INDENT node_name wrap? (SP+ node_width_expansion)? (SP+ node_height_expansion)? SP+ node_placement (SP+ color_tag)? EOL*
node_name = name
node_width_expansion = number '%'  // Increase the width of the node
node_height_expansion = comp_height_expansion (SP+ comp_height_expansion)*  // A node's height is the sum of its expanded compartments
comp_height_expansion = '[C' number ']' number '%'  // Increase the height of a single compartment
node_placement = grid_place (SP+ ':' SP+ grid_place)*  // One or more such locations
grid_place = node_loc (SP+ node_align)? // Location in grid where a node will appear
node_loc = span ',' span  // Row and column
span =  number '-' number / number
color_tag = '<' name '>'

// Connector
connector_block = connectors_header connector_layout+ // All
connectors_header = "connectors" EOL* // starts section where connector layout info is specified
connector_layout = INDENT cname_place?  ( binary_layout / tree_layout / unary_layout ) EOL*
cname_place = dir? name wrap? bend? notch? csep // Side of connector axis and name of connector (since it is probably short)
bend = '.' number // Bend in connector where 1 is at the tstem side increasing to the pstem side

// Binary connector
binary_layout = tstem csep pstem ternary_node? (csep paths)? // All layout info for a binary connector
tstem = stem_side // one stem in a binary connector (t and p are arbitary names)
pstem = stem_side // the opposite stem in a binary connector
ternary_node = ',' SP+ node_face
paths = path (SP+ path)*
sname_place = dir wrap  // Side of stem axis and number of text lines after wrapping in stem name text block
stem_side = (sname_place SP+)? node_face // Either the tstem or pstem layout

// Tree layout
tree_layout = trunk_face (SP+ branch)+ // All layout info for a tree connector
trunk_face = node_face ('>')? // May or may not graft the trunk branch with > symbol
branch = '{ ' leaf_faces (csep path)? ' }' // A branch is attached to one or more leaf faces
leaf_faces = leaf_face (', ' leaf_face)*
leaf_face = node_face ('>>' / '>' )?  // graft its own branch or the next one
// Within a branch, one leaf may either graft that branch > or graft the subsequent branch >>
// See patterns 3 and 2 respectively in tech note tn.2 in the documentation folder for examples
// There are three ways to specify the path of a branch:
//    1) Interpolated - Compute position between opposing node faces (no specification)
//    2) Grafted - Line up branch with some face placement (a > on the trunk or some leaf face or a >> on a leaf face)
//    3) Rut - Run branch down a rut in a lane as specified by a path (path)
// A branch that is neither interpolated nor grafted has a path specified where it runs

// Unary connector
unary_layout = stem_side

// Face attachment
node_ref = name ('.' number)? // Optional additional placement of the same node
face =  "t" / "b" / "l" / "r" // top, bottom, left or right node face
dir = "+" / "-" // direction of increasing coord values, up and to the right is positive
csep = SP+ ':' SP+ // argument separator
anchor = notch / '*'
node_face = face anchor? "|" node_ref // Where a stem attaches to a node face

// Alignment
valign = ">" ("top" / "bottom")
halign = ">" ("right" / "left")
node_align = valign SP? halign / halign SP? valign / valign / halign
// A notch is based on a system where 0 means 'centered' and deviations from the center are proportional
// increments, each the same size, distant from the center in the positive or negative direction
// Positive is always in the increasing coordinate direction, up or to the right
notch = '0' / ('+' / '-') number // A unit of alignment, center, or a positive or negative integer
path = 'L' number ('R' notch)? // Lane and rut, assume rut 0 if R not specified

// Elements
wrap = '/' number // Number of lines to wrap an associated string
number = r'[1-9][0-9]*' // Always a positive integer

// Model element names
// A name is one or more words separated by a delimiter
delim = r'[ _]' // Delimiter to separate words in a name
word = r'[A-Za-z][A-Za-z0-9?]*' // String of alpahnumeric text with no whitespace starting with alpha char
name = word (delim word)* // Sequence of delimited words forming a name

// Whitespace and comments
INDENT = "    "  // For clarity
EOL = SP* COMMENT? '\n' // end of line: Comments, blank lines, whitespace we can omit from the parser result
COMMENT = '//' r'.*' // Comment slashes don't work if included in the regular expression for some reason
SP = " "
