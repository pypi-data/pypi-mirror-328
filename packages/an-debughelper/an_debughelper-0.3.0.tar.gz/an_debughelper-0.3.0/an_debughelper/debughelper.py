# -*- coding: utf-8 -*-
"""DBHL_20250218_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DQoC4wTBk-5UPG9oHFn79egeYVUXWD3y

# DebugHelper
ãƒ‡ãƒãƒƒã‚°ä½œæ¥­ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã€‚


```
2025/01/18 DebugHelper2ã‚’pipåŒ–ã™ã‚‹ãŸã‚ã«ä½œæˆ
2025/01/19 flg_debugã‚’ãªãã™ãŸã‚ã®ä¿®æ­£
2025/02/11 0.2.1 CheckpointManagerè¿½åŠ 
2025/02/12 0.2.2 log_stepæ”¹è‰¯ã€‚å®Ÿè¡Œä¸­ã®ã‚¯ãƒ©ã‚¹ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«ã—ãŸã€‚
2025/02/13 0.2.3 what_do_you_do ã‚’è¿½åŠ ã€‚ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œã‚’é¸æŠã§ãã‚‹ã‚ˆã†ã«ã—ãŸã€‚
2025/02/14 0.2.4 what_do_you_do æ”¹è‰¯ã€‚æˆ»ã‚Šå€¤é–¢ä¿‚ã€‚
2025/02/14 0.2.5 what_do_you_do æ”¹è‰¯ã€‚è¡¨ç¤ºæ–¹æ³•ã€‚
2025/02/14 0.2.7 what_do_you_do æ”¹è‰¯ã€‚ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ©Ÿèƒ½ã€ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—æ©Ÿèƒ½
2025/02/15 0.2.8 ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ©Ÿèƒ½æ”¹è‰¯ã€‚ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«åã«ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å…¥ã‚Œã‚‹ã€‚
2025/02/15 0.2.9 log_stepãƒã‚°ä¿®æ­£ã€‚æ•´ç†ã®ãŸã‚ã€ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒƒã‚¯æ•°ã‚’5ã¤ã«åˆ¶é™ã™ã‚‹ã€‚
2025/02/15 0.2.10 log_step æ”¹è‰¯ã€‚å¼•æ•°charã§å†’é ­æ–‡å­—ã®å¹…ã‚’åºƒã’ã‚‹ã€‚
2025/02/16 0.2.11 log_step æ”¹è‰¯ã€‚æˆ»ã‚Šå€¤é–¢ä¿‚ã€‚
2025/02/16 0.2.12 run_command æ”¹è‰¯ã€‚ãƒ­ã‚°ã‚’å‡ºåŠ›ã€‚
2025/02/17 0.2.13 run_command æ”¹è‰¯ã€‚subprocessã‚’åˆ©ç”¨ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
2025/02/17 0.2.14 run_command æ”¹è‰¯ã€‚booleanã ã‘ã§ãªãã€numericã‚‚è¿”ã™ã€‚
2025/02/18 0.2.15 run_command æ”¹è‰¯ã€‚stdoutã‚’ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã™ã‚ˆã†ã«ã™ã‚‹ã€‚
2025/02/18 0.3.00 run_command æ”¹è‰¯ã€‚stderrã‚‚ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã™ã‚ˆã†ã«ã™ã‚‹ã€‚
```

# DebugHelper

## 1. åˆæœŸè¨­å®š
"""

# @title a. åˆæœŸå€¤è¨­å®š{"form-width":"400px"}
# @markdown Log_folder, Log_file(ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‚’è¨˜éŒ²)
log_folder = "/content/drive/MyDrive/log"  # @param {type:"string"}
log_file_stdout = ""  # @param {type:"string", "placeholder":"ä½•ã‚‚å…¥åŠ›ã—ãªã‘ã‚Œã°ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã«ãªã‚Šã¾ã™"}
log_file_stderr = ""  # @param {type:"string", "placeholder":"ä½•ã‚‚å…¥åŠ›ã—ãªã‘ã‚Œã°ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã«ãªã‚Šã¾ã™"}

# @title b. GDriveæ¥ç¶š
from google.colab import drive
drive.mount('/content/drive')

"""## 2. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©"""

# @title a. DebugHelper å®šç¾©{"form-width":"400px"}
import os
import sys
import inspect
import subprocess
import threading
from datetime import datetime
from pathlib import Path

class DebugHelper:
    def __init__(self):
        """ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚„ãƒ­ã‚°ç®¡ç†ã‚’è¡Œã†ã‚¯ãƒ©ã‚¹"""
        self.debug = True
        self.entries = []  # è¨˜éŒ²ã™ã‚‹ã‚¨ãƒ³ãƒˆãƒªä¸€è¦§
        self.wNo = 1
        self.silent_mode = False  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ Falseï¼ˆå¯¾è©±ãƒ¢ãƒ¼ãƒ‰ï¼‰
        # æ—¢å­˜ã®ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«è¨­å®šï¼ˆæ±ç”¨ç”¨ï¼‰
        self.log_to_file = False
        self.log_file_path = None
        # æ–°ãŸã«æ¨™æº–å‡ºåŠ›ç”¨ã¨æ¨™æº–ã‚¨ãƒ©ãƒ¼ç”¨ã®ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«è¨­å®šã‚’è¿½åŠ 
        self.log_to_file_stdout = False
        self.log_file_path_stdout = None
        self.log_to_file_stderr = False
        self.log_file_path_stderr = None

        self.timestamp = False  # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—æœ‰åŠ¹åŒ–

    def enable_debug(self):
        self.debug = True

    def disable_debug(self):
        self.debug = False

    def enable_silent_mode(self):
        self.silent_mode = True

    def disable_silent_mode(self):
        self.silent_mode = False

    def prune_log_files(self, log_file_path, max_files=5):
        # ã™ã§ã«ã‚ã‚‹ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ*.logï¼‰ã‚’ã€æœ€æ–° max_files å€‹ä»¥å¤–å‰Šé™¤
        log_path = log_file_path.parent
        self.debug_print(f"log_path: {log_path}")
        files = list(log_path.glob("*.log"))
        if len(files) <= max_files:
            return
        files.sort(key=lambda f: f.stat().st_mtime)
        for f in files[:-max_files]:
            try:
                f.unlink()
                print(f"Deleted old log file: {f}")
            except Exception as e:
                print(f"Error deleting {f}: {e}")

    def enable_log_to_file_stdout(self, log_file_path=Path(os.path.join(log_folder, log_file_stdout))):
        """æ¨™æº–å‡ºåŠ›ã®ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®å‡ºåŠ›ã‚’æœ‰åŠ¹ã«ã™ã‚‹"""
        self.log_to_file_stdout = True
        self.log_file_path_stdout = log_file_path
        if self.log_file_path_stdout.is_dir():
            filename = "Stdout_Rec_" + datetime.now().strftime("%Y_%m_%d_%H_%M_%S") + ".log"
            self.log_file_path_stdout = self.log_file_path_stdout / filename
            self.prune_log_files(self.log_file_path_stdout)
        elif self.log_file_path_stdout.is_file():
            pass
        else:
            self.debug_print(f"âš ï¸ ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ (stdout) ãŒä¸æ­£ã§ã™: {self.log_file_path_stdout}")
            sys.exit(1)
        self.debug_print(f"âœ… æ¨™æº–å‡ºåŠ›ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã‚’æœ‰åŠ¹åŒ–: {self.log_file_path_stdout}")

    def enable_log_to_file_stderr(self, log_file_path=Path(os.path.join(log_folder, log_file_stderr))):
        """æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã®ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®å‡ºåŠ›ã‚’æœ‰åŠ¹ã«ã™ã‚‹"""
        self.log_to_file_stderr = True
        self.log_file_path_stderr = log_file_path
        if self.log_file_path_stderr.is_dir():
            filename = "Stderr_Rec_" + datetime.now().strftime("%Y_%m_%d_%H_%M_%S") + ".log"
            self.log_file_path_stderr = self.log_file_path_stderr / filename
            self.prune_log_files(self.log_file_path_stderr)
        elif self.log_file_path_stderr.is_file():
            pass
        else:
            self.debug_print(f"âš ï¸ ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ (stderr) ãŒä¸æ­£ã§ã™: {self.log_file_path_stderr}")
            sys.exit(1)
        self.debug_print(f"âœ… æ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã‚’æœ‰åŠ¹åŒ–: {self.log_file_path_stderr}")

    def disable_log_to_file(self):
        self.log_to_file = False
        self.log_to_file_stdout = False
        self.log_to_file_stderr = False
        self.debug_print("ğŸ›‘ ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã‚’ç„¡åŠ¹åŒ–")

    def enable_timestamp(self):
        self.timestamp = True

    def disable_timestamp(self):
        self.timestamp = False

    def start_step(self, step_name):
        print(f"ğŸ”¹ ãƒã‚§ãƒƒã‚¯é–‹å§‹: {step_name}")
        self.entries.append({"ã‚¹ãƒ†ãƒƒãƒ—": step_name, "å†…å®¹": "é€²è¡Œä¸­", "çµæœ": "âš ï¸ é€²è¡Œä¸­"})

    def add_step(self, step_key, description):
        if step_key not in self.entries:
            self.entries.append({
                "ã‚¹ãƒ†ãƒƒãƒ—": step_key,
                "å‡¦ç†å†…å®¹": description,
                "çµæœ": "æœªå®Ÿè¡Œ"
            })
        else:
            print(f"âš ï¸ æ‰‹é † {step_key} ã¯ã™ã§ã«ç™»éŒ²æ¸ˆã¿ã§ã™ã€‚")

    def complete_step(self, step_name, success=True):
        for entry in self.entries:
            if entry["ã‚¹ãƒ†ãƒƒãƒ—"] == step_name:
                entry["çµæœ"] = "âœ… æˆåŠŸ" if success else "âŒ å¤±æ•—"
                return
        print(f"âš ï¸ ã‚¹ãƒ†ãƒƒãƒ— `{step_name}` ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")

    def debug_print(self, *args, end="\n", back=0):
        cls_name, method_name = self.get_current_method_info(back=back)
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        if self.timestamp:
            message = f"{timestamp} [{cls_name}.{method_name}] " + " ".join(map(str, args))
        else:
            message = f"[{cls_name}.{method_name}] " + " ".join(map(str, args))

        print(message, end=end)

        # ã“ã“ã§ã¯ã€stdoutç”¨ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›ã™ã‚‹
        if self.log_to_file_stdout and self.log_file_path_stdout:
            try:
                with open(self.log_file_path_stdout, "a", encoding="utf-8") as log_file:
                    log_file.write(message + end)
            except Exception as e:
                print(f"ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿ã‚¨ãƒ©ãƒ¼ (stdout): {e}")



    def log_step(self, *args, end="\n", success=None, char=None, back=0):
        if char is None:
            if success is True:
                full_message = "âœ… " + " ".join(map(str, args))
            elif success is False:
                full_message = "âŒ " + " ".join(map(str, args))
            else:
                full_message = "ğŸ”¹ " + " ".join(map(str, args))
        else:
            full_message = char + " " + " ".join(map(str, args))
        self.debug_print(full_message, end=end, back=back+1)

    def what_do_you_do(self, message, command):
        length = 100
        self.debug_print("\n" + "=" * length, back=1)
        mode_msg = "Silent mode: å³å®Ÿè¡Œ" if self.silent_mode else "Action mode: ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›"
        self.debug_print(f"\nğŸ”¹ğŸ”¹ğŸ”¹ğŸ”¹ğŸ”¹ No.{self.wNo} {mode_msg} ğŸ”¹ğŸ”¹ğŸ”¹ğŸ”¹ğŸ”¹\n" + "-" * length, back=1)
        self.wNo += 1
        self.debug_print(f"\nğŸ®èª¬æ˜\n{message}", back=1)
        self.debug_print(f"\nğŸ¤”ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\n{command}\n" + "-" * length, back=1)
        if not self.silent_mode:
            self.debug_print("\nğŸ“ ã‚³ãƒãƒ³ãƒ‰\n1ï¸âƒ£ å®Ÿè¡Œã™ã‚‹ 2ï¸âƒ£ ã‚„ã‚ã¦ãŠã 3ï¸âƒ£ ã‚³ãƒãƒ³ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹ 4ï¸âƒ£ ã“ã“ã§ä¸­æ–­", back=1)
            choice = input("\nğŸ”¹ ã©ã†ã™ã‚‹ï¼Ÿ (1/2/3/4): ").strip()
            if choice == "1":
                pass
            elif choice == "2":
                self.debug_print("\nğŸ›‘ æ“ä½œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚", back=1)
                return None, None
            elif choice == "3":
                command = input("\nğŸ’¬ æ–°ã—ã„ã‚³ãƒãƒ³ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: ").strip()
            elif choice == "4":
                self.debug_print("\nğŸ‘‹ ä¸­æ–­ã—ã¾ã™ã€‚", back=1)
                sys.exit(1)
            else:
                self.debug_print("\nâš ï¸ ç„¡åŠ¹ãªé¸æŠè‚¢ã§ã™", back=1)
                return None, None
        self.debug_print(f"\nğŸš€ å®Ÿè¡Œä¸­:\n{command}", back=1)
        try:
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            self.debug_print("\nâœ… ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œå®Œäº†\n" + "-" * length, back=1)
            self.debug_print(f"\nstdout:\n{result.stdout}", back=1)
            self.debug_print(f"\nstderr:\n{result.stderr}\n" + "=" * length + "\n\n\n", back=1)
            return result.stdout, result.stderr
        except Exception as e:
            self.debug_print(f"\nâŒ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}", back=1)
            return None, None

    def get_current_method_info(self, back=0):
        frame = inspect.currentframe()
        for _ in range(2 + back):
            if frame is None or frame.f_back is None:
                break
            frame = frame.f_back
        method_name = frame.f_code.co_name if frame else "Unknown"
        cls_name = None
        if frame and 'self' in frame.f_locals:
            cls_name = frame.f_locals['self'].__class__.__name__
        return cls_name, method_name

    def add_entry(self, category, description, success=None):
        status = "âœ… æˆåŠŸ" if success is True else "âŒ å¤±æ•—" if success is False else "âš ï¸ æœªåˆ¤å®š"
        entry = {"ã‚«ãƒ†ã‚´ãƒª": category, "å‡¦ç†å†…å®¹": description, "çµæœ": status}
        self.entries.append(entry)



    def display(self):
        """ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã¨stdoutç”¨ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«è¡¨ç¤ºã™ã‚‹"""
        output_lines = []
        output_lines.append("\nğŸ”¹ **ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ** ğŸ”¹")
        for idx, entry in enumerate(self.entries, start=1):
            category = entry.get("ã‚«ãƒ†ã‚´ãƒª", entry.get("ã‚¹ãƒ†ãƒƒãƒ—", "ä¸æ˜"))
            description = entry.get("å‡¦ç†å†…å®¹", entry.get("å†…å®¹", "èª¬æ˜ãªã—"))
            result = entry.get("çµæœ", "âš ï¸ æœªåˆ¤å®š")
            line = f"Step {idx}: [{category}] {description} â†’ {result}"
            output_lines.append(line)

        # ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›
        for line in output_lines:
            print(line)

        # stdoutãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¸å‡ºåŠ›ï¼ˆæœ‰åŠ¹ã®å ´åˆï¼‰
        if self.log_to_file_stdout and self.log_file_path_stdout:
            try:
                with open(self.log_file_path_stdout, "a", encoding="utf-8") as f:
                    for line in output_lines:
                        f.write(line + "\n")
            except Exception as e:
                self.debug_print(f"stdoutãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®å‡ºåŠ›ã‚¨ãƒ©ãƒ¼: {e}")

    def export_log(self):
        """ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’stdoutç”¨ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›ã™ã‚‹"""
        if not self.log_file_path_stdout:
            self.debug_print("âš ï¸ stdoutãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", back=1)
            return
        try:
            with open(self.log_file_path_stdout, "w", encoding="utf-8") as f:
                for idx, entry in enumerate(self.entries, start=1):
                    category = entry.get("ã‚«ãƒ†ã‚´ãƒª", entry.get("ã‚¹ãƒ†ãƒƒãƒ—", "ä¸æ˜"))
                    description = entry.get("å‡¦ç†å†…å®¹", entry.get("å†…å®¹", "èª¬æ˜ãªã—"))
                    result = entry.get("çµæœ", "âš ï¸ æœªåˆ¤å®š")
                    f.write(f"Step {idx}: [{category}] {description} â†’ {result}\n")
            print(f"âœ… ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ {self.log_file_path_stdout} ã«ä¿å­˜ã—ã¾ã—ãŸã€‚")
        except Exception as e:
            self.debug_print(f"stdoutãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}", back=1)



    def clear(self):
        self.entries = []
        self.debug_print("âœ… ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚", back=1)

    def run_command(self, command, timeout=900, back=1, stdout=False, stderr=False):
        """
        ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§å®Ÿè¡Œã—ã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã¨ãã‚Œãã‚Œã®ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›ã™ã‚‹ã€‚

        Args:
            command (str): å®Ÿè¡Œã™ã‚‹ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰
            timeout (int): ã‚³ãƒãƒ³ãƒ‰ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“ï¼ˆç§’ï¼‰
            back (int): ãƒ­ã‚°å‡ºåŠ›ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            stdout (bool): Trueã®å ´åˆã€æ¨™æº–å‡ºåŠ›ã®ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’æœ‰åŠ¹ã«ã™ã‚‹
            stderr (bool): Trueã®å ´åˆã€æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã®ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’æœ‰åŠ¹ã«ã™ã‚‹

        Returns:
            tuple: (çµ‚äº†ã‚³ãƒ¼ãƒ‰, æ¨™æº–å‡ºåŠ› (str or None), æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ› (str or None))
        """
        self.log_step(f"ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ: {command}", success=None, back=back)
        stdout_data, stderr_data = [], []

        def monitor_output(stream, log_func, capture_list, log_file):
            try:
                for line in iter(stream.readline, ''):
                    log_func(line)
                    sys.stdout.flush()
                    capture_list.append(line)
                    if log_file:
                        log_file.write(line)
                        log_file.flush()
            except Exception as e:
                self.log_step(f"ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ä¸­ã‚¨ãƒ©ãƒ¼: {str(e)}", success=False, back=back, char="ğŸ’¥")

        try:
            process = subprocess.Popen(
                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1
            )

            # stdoutç”¨ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            if self.log_to_file_stdout and self.log_file_path_stdout:
                log_file_stdout = open(self.log_file_path_stdout, "a", encoding="utf-8")
            else:
                log_file_stdout = None

            # stderrç”¨ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            if self.log_to_file_stderr and self.log_file_path_stderr:
                log_file_stderr = open(self.log_file_path_stderr, "a", encoding="utf-8")
            else:
                log_file_stderr = None

            stdout_thread = threading.Thread(target=monitor_output, args=(process.stdout, sys.stdout.write, stdout_data, log_file_stdout))
            stderr_thread = threading.Thread(target=monitor_output, args=(process.stderr, sys.stderr.write, stderr_data, log_file_stderr))

            stdout_thread.start()
            stderr_thread.start()

            process.wait(timeout=timeout)
            stdout_thread.join()
            stderr_thread.join()

            if log_file_stdout:
                log_file_stdout.close()
            if log_file_stderr:
                log_file_stderr.close()

            stdout_result = ''.join(stdout_data) if stdout else None
            stderr_result = ''.join(stderr_data) if stderr else None

            if process.returncode == 0:
                self.log_step(f"ã‚³ãƒãƒ³ãƒ‰æˆåŠŸ: {command} (ã‚³ãƒ¼ãƒ‰: {process.returncode})", success=True, back=back)
            else:
                self.log_step(f"ã‚³ãƒãƒ³ãƒ‰å¤±æ•—: {command} (ã‚³ãƒ¼ãƒ‰: {process.returncode})", success=False, back=back)

            return process.returncode, stdout_result, stderr_result

        except subprocess.TimeoutExpired:
            self.log_step(f"â³ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {command}", char="âš ï¸", back=back)
            return -1, None, None
        except Exception as e:
            self.log_step(f"ğŸ’¥ å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {command}\n{str(e)}", success=False, back=back)
            return -2, None, None

"""## 2. ãƒ†ã‚¹ãƒˆ"""

# @title a. ãƒ†ã‚¹ãƒˆ {"form-width":"400px"}
class TestClass:
    def __init__(self):
        self.debugger = DebugHelper()
        self.debugger.debug_print("TestClassã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚")
        self.debugger.log_step("TestClassã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚", success=True)
        self.debugger.add_entry("ãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹", "TestClassã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚", success=True)
        self.debugger.add_step("ãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹", "TestClassã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚")
        self.debugger.display()
        self.debugger.export_log()
        self.debugger.clear()


    def test_method(self):
        self.debugger.enable_log_to_file_stdout()
        self.debugger.enable_log_to_file_stderr()
        self.debugger.enable_timestamp()
        self.debugger.enable_silent_mode()
        self.debugger.log_step("ã«ã‚ƒã«ã‚ƒã«ã‚ƒãµ", char = "ğŸˆ")
        self.debugger.log_step("ã«ã‚ƒã«ã‚ƒã«ã‚ƒãµ", char = "ğŸˆ", back = 1)
        self.debugger.add_entry("ãƒ†ã‚¹ãƒˆãƒ¡ã‚½ãƒƒãƒ‰", "test_methodãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚", success=True)
        # self.debugger.what_do_you_do("ãƒã‚«ã‚!!!", "echo ãƒã‚«ã‚ãƒã‚«ã‚ãƒã‚«ã‚!!!")
        self.debugger.disable_silent_mode()
        # self.debugger.what_do_you_do("ãã†ã¯ã„ãã‹!!!!", "echo ã¡ã‡ã™ã¨ã‰ã‰ã‰ã‰!!!")
        self.debugger.run_command( "ls -l" )
        result, stdout, stderr = self.debugger.run_command("nvcc --version", stdout = True, stderr = True)
        print( f"result : {result}")
        print( f"stdout : {stdout}")
        print( f"stderr : {stderr}")
        if not result:
            for line in stdout.split("\n"):
                if "release" in line:
                    version = line.split(",")[1].strip().split(" ")[1]
                    self.debugger.log_step(f"CUDA ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ¤œå‡º: {version}", success=True)
                    break



if __name__ == "__main__":
    tc1 = TestClass()
    tc1.test_method()