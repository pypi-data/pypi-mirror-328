# coding: utf-8

"""
    Deel REST API

    Deel REST API

    The version of the OpenAPI document: 1.25.0
    Contact: apiteam@deel.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from dima_test_sdk.models.eor_termination_request_request_additional_country_data_inner import EorTerminationRequestRequestAdditionalCountryDataInner
from dima_test_sdk.models.eor_termination_request_request_attachments_inner import EorTerminationRequestRequestAttachmentsInner
from dima_test_sdk.models.eor_termination_request_request_used_time_off import EorTerminationRequestRequestUsedTimeOff
from typing import Optional, Set
from typing_extensions import Self

class EorTerminationRequestRequest(BaseModel):
    """
    EorTerminationRequestRequest
    """ # noqa: E501
    reason: StrictStr = Field(description="Reason why the contract is being terminated")
    attachments: Optional[List[EorTerminationRequestRequestAttachmentsInner]] = Field(default=None, description="Any document that is important for the request to terminate the contract")
    is_sensitive: Optional[StrictBool] = Field(default=None, description="Defines whether the termination is sensitive. In this case, only the person requesting the termination will be able to view the termination, receive emails or notifications.")
    reason_detail: Annotated[str, Field(min_length=100, strict=True, max_length=5000)] = Field(description="Field to better explain how communication with the employee will be and/or their reaction to the communication, or other necessary information")
    used_time_off: EorTerminationRequestRequestUsedTimeOff
    severance_type: Optional[StrictStr] = Field(default=None, description="The type of severance selected by the client. It's an optional field")
    desired_end_date: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="The desired end date. If the date is not provided, it will be selected by HRX the closest date possible")
    severance_amount: Optional[Union[Annotated[float, Field(strict=True, ge=0)], Annotated[int, Field(strict=True, ge=0)]]] = Field(default=None, description="The amount of severance needed")
    additional_reason: Optional[StrictStr] = Field(default=None, description="An additional reason can be provided in case the reason selected is NO_LONGER_WISH_TO_WORK_WITH_DEEL")
    termination_notes: Optional[List[Annotated[str, Field(strict=True, max_length=5000)]]] = Field(default=None, description="Additional notes can be provided regarding the termination for Deel, like questions and doubts")
    eligible_for_rehire: Optional[StrictStr] = Field(default=None, description="Parameter to inform whether it would be possible for the client to hire the employee again")
    eor_country_data_id: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The current country data id")
    is_employee_notified: StrictBool = Field(description="Defines if employee was informed by client or not before the termination")
    termination_impact_id: Optional[StrictStr] = Field(default=None, description="Termination impact data if there is some configured on HR module")
    additional_country_data: Optional[List[EorTerminationRequestRequestAdditionalCountryDataInner]] = Field(default=None, description="For some countries some data is needed to help Deel to process the termination. The questions comes from another endpoint to get the additional country data")
    custom_termination_reason_id: Optional[StrictStr] = Field(default=None, description="Custom termination reason ID. A custom termination reason can be added on Client HR module")
    employee_notification_detail: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=5000)]] = Field(default=None, description="If it's an termination contract ending and employee was already informed, the employee notification details should be provided")
    additional_supporting_documents: Optional[List[EorTerminationRequestRequestAttachmentsInner]] = Field(default=None, description="Any proof such as correspondence, documentation of previous warnings or attendance records for the reason select above.")
    __properties: ClassVar[List[str]] = ["reason", "attachments", "is_sensitive", "reason_detail", "used_time_off", "severance_type", "desired_end_date", "severance_amount", "additional_reason", "termination_notes", "eligible_for_rehire", "eor_country_data_id", "is_employee_notified", "termination_impact_id", "additional_country_data", "custom_termination_reason_id", "employee_notification_detail", "additional_supporting_documents"]

    @field_validator('reason')
    def reason_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['DEEL_COLLECTIONS', 'STATUS_CHANGE', 'RELOCATION', 'COMPENSATION', 'RETIREMENT', 'JOB_ABANDONMENT', 'WORK_RELATED', 'PERSONAL', 'OTHER_OPPORTUNITY', 'NON_RENEWAL', 'PROBATION', 'ASSIGNMENT_ENDED', 'POSITION_ELIMINATION', 'FORCE_REDUCTION', 'DEATH', 'FOR_CAUSE', 'PERFORMANCE', 'MEDICAL', 'PERFORMANCE_ISSUES', 'ATTENDANCE_ISSUES', 'REORGANIZATION_DOWNSIZING_BUDGET_OR_REDUCTION_OF_WORKFORCE', 'ROLE_BECAME_REDUNDANT_OR_ROLE_CHANGED', 'OFFER_WAS_REVOKED', 'EXITING_THE_MARKET', 'NO_LONGER_WISH_TO_WORK_WITH_DEEL', 'COMPANY_ACQUIRED', 'STEALING', 'MISCONDUCT', 'FALSIFYING', 'HARASSMENT', 'VIOLENCE', 'REORGANIZATION_DOWNSIZING_BUDGET_OR_REDUCTION_OF_WORKFORCE_OR_ROLE_BECAME_REDUNDANT_OR_ROLE_CHANGED', 'UNAUTHORIZED_ABSENCES_OR_LACK_OF_ATTENDANCE', 'STANDARD_RESELLER_PRACTICE', 'MOVING_EMPLOYEE_TO_INTERNAL_ENTITY', 'MOVING_EMPLOYEE_TO_DEEL_PEO', 'OTHER']):
            raise ValueError("must be one of enum values ('DEEL_COLLECTIONS', 'STATUS_CHANGE', 'RELOCATION', 'COMPENSATION', 'RETIREMENT', 'JOB_ABANDONMENT', 'WORK_RELATED', 'PERSONAL', 'OTHER_OPPORTUNITY', 'NON_RENEWAL', 'PROBATION', 'ASSIGNMENT_ENDED', 'POSITION_ELIMINATION', 'FORCE_REDUCTION', 'DEATH', 'FOR_CAUSE', 'PERFORMANCE', 'MEDICAL', 'PERFORMANCE_ISSUES', 'ATTENDANCE_ISSUES', 'REORGANIZATION_DOWNSIZING_BUDGET_OR_REDUCTION_OF_WORKFORCE', 'ROLE_BECAME_REDUNDANT_OR_ROLE_CHANGED', 'OFFER_WAS_REVOKED', 'EXITING_THE_MARKET', 'NO_LONGER_WISH_TO_WORK_WITH_DEEL', 'COMPANY_ACQUIRED', 'STEALING', 'MISCONDUCT', 'FALSIFYING', 'HARASSMENT', 'VIOLENCE', 'REORGANIZATION_DOWNSIZING_BUDGET_OR_REDUCTION_OF_WORKFORCE_OR_ROLE_BECAME_REDUNDANT_OR_ROLE_CHANGED', 'UNAUTHORIZED_ABSENCES_OR_LACK_OF_ATTENDANCE', 'STANDARD_RESELLER_PRACTICE', 'MOVING_EMPLOYEE_TO_INTERNAL_ENTITY', 'MOVING_EMPLOYEE_TO_DEEL_PEO', 'OTHER')")
        return value

    @field_validator('severance_type')
    def severance_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DAYS', 'WEEKS', 'MONTHS', 'CASH']):
            raise ValueError("must be one of enum values ('DAYS', 'WEEKS', 'MONTHS', 'CASH')")
        return value

    @field_validator('desired_end_date')
    def desired_end_date_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\d{4}-\d{2}-\d{2}$", value):
            raise ValueError(r"must validate the regular expression /^\d{4}-\d{2}-\d{2}$/")
        return value

    @field_validator('additional_reason')
    def additional_reason_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DISSATISFIED_WITH_DEEL_SERVICE', 'DISSATISFIED_WITH_DEEL_PRICING', 'DISSATISFIED_WITH_DEEL_PRODUCT']):
            raise ValueError("must be one of enum values ('DISSATISFIED_WITH_DEEL_SERVICE', 'DISSATISFIED_WITH_DEEL_PRICING', 'DISSATISFIED_WITH_DEEL_PRODUCT')")
        return value

    @field_validator('eligible_for_rehire')
    def eligible_for_rehire_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['YES', 'NO', 'DONT_KNOW']):
            raise ValueError("must be one of enum values ('YES', 'NO', 'DONT_KNOW')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of EorTerminationRequestRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in attachments (list)
        _items = []
        if self.attachments:
            for _item_attachments in self.attachments:
                if _item_attachments:
                    _items.append(_item_attachments.to_dict())
            _dict['attachments'] = _items
        # override the default output from pydantic by calling `to_dict()` of used_time_off
        if self.used_time_off:
            _dict['used_time_off'] = self.used_time_off.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in additional_country_data (list)
        _items = []
        if self.additional_country_data:
            for _item_additional_country_data in self.additional_country_data:
                if _item_additional_country_data:
                    _items.append(_item_additional_country_data.to_dict())
            _dict['additional_country_data'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in additional_supporting_documents (list)
        _items = []
        if self.additional_supporting_documents:
            for _item_additional_supporting_documents in self.additional_supporting_documents:
                if _item_additional_supporting_documents:
                    _items.append(_item_additional_supporting_documents.to_dict())
            _dict['additional_supporting_documents'] = _items
        # set to None if additional_reason (nullable) is None
        # and model_fields_set contains the field
        if self.additional_reason is None and "additional_reason" in self.model_fields_set:
            _dict['additional_reason'] = None

        # set to None if eligible_for_rehire (nullable) is None
        # and model_fields_set contains the field
        if self.eligible_for_rehire is None and "eligible_for_rehire" in self.model_fields_set:
            _dict['eligible_for_rehire'] = None

        # set to None if employee_notification_detail (nullable) is None
        # and model_fields_set contains the field
        if self.employee_notification_detail is None and "employee_notification_detail" in self.model_fields_set:
            _dict['employee_notification_detail'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of EorTerminationRequestRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "reason": obj.get("reason"),
            "attachments": [EorTerminationRequestRequestAttachmentsInner.from_dict(_item) for _item in obj["attachments"]] if obj.get("attachments") is not None else None,
            "is_sensitive": obj.get("is_sensitive"),
            "reason_detail": obj.get("reason_detail"),
            "used_time_off": EorTerminationRequestRequestUsedTimeOff.from_dict(obj["used_time_off"]) if obj.get("used_time_off") is not None else None,
            "severance_type": obj.get("severance_type"),
            "desired_end_date": obj.get("desired_end_date"),
            "severance_amount": obj.get("severance_amount"),
            "additional_reason": obj.get("additional_reason"),
            "termination_notes": obj.get("termination_notes"),
            "eligible_for_rehire": obj.get("eligible_for_rehire"),
            "eor_country_data_id": obj.get("eor_country_data_id"),
            "is_employee_notified": obj.get("is_employee_notified"),
            "termination_impact_id": obj.get("termination_impact_id"),
            "additional_country_data": [EorTerminationRequestRequestAdditionalCountryDataInner.from_dict(_item) for _item in obj["additional_country_data"]] if obj.get("additional_country_data") is not None else None,
            "custom_termination_reason_id": obj.get("custom_termination_reason_id"),
            "employee_notification_detail": obj.get("employee_notification_detail"),
            "additional_supporting_documents": [EorTerminationRequestRequestAttachmentsInner.from_dict(_item) for _item in obj["additional_supporting_documents"]] if obj.get("additional_supporting_documents") is not None else None
        })
        return _obj


