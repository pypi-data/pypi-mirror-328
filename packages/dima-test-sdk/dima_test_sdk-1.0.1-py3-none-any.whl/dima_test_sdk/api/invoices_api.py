# coding: utf-8

"""
    Deel REST API

    Deel REST API

    The version of the OpenAPI document: 1.25.0
    Contact: apiteam@deel.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import date
from pydantic import Field, StrictStr, field_validator
from typing import Any, Optional
from typing_extensions import Annotated
from dima_test_sdk.models.create_invoice_adjustment201_response import CreateInvoiceAdjustment201Response
from dima_test_sdk.models.create_invoice_adjustment_request import CreateInvoiceAdjustmentRequest
from dima_test_sdk.models.generic_result_created import GenericResultCreated
from dima_test_sdk.models.get_invoice_adjustments200_response import GetInvoiceAdjustments200Response
from dima_test_sdk.models.get_invoice_adjustments_by_contract_id200_response import GetInvoiceAdjustmentsByContractId200Response
from dima_test_sdk.models.get_invoice_adjustments_by_id200_response import GetInvoiceAdjustmentsById200Response
from dima_test_sdk.models.invoice_adjustment_reviews_to_create_container import InvoiceAdjustmentReviewsToCreateContainer
from dima_test_sdk.models.uninvite_to_sign_contract200_response import UninviteToSignContract200Response
from dima_test_sdk.models.update_adjustment200_response import UpdateAdjustment200Response
from dima_test_sdk.models.update_invoice_adjustment200_response import UpdateInvoiceAdjustment200Response
from dima_test_sdk.models.update_invoice_adjustment_by_id_request import UpdateInvoiceAdjustmentByIdRequest
from dima_test_sdk.models.update_invoice_adjustment_request import UpdateInvoiceAdjustmentRequest

from dima_test_sdk.api_client import ApiClient, RequestSerialized
from dima_test_sdk.api_response import ApiResponse
from dima_test_sdk.rest import RESTResponseType


class InvoicesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_invoice_adjustment(
        self,
        create_invoice_adjustment_request: Annotated[CreateInvoiceAdjustmentRequest, Field(description="InvoiceAdjustment object that needs to be created")],
        recurring: Annotated[Optional[StrictStr], Field(description="Add this invoice adjustment as recurring")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateInvoiceAdjustment201Response:
        """Create an invoice adjustment

        Create an invoice adjustment using this endpoint. For example, you can add a bonus, commission, VAT %, deduction etc. to an invoice.  **Token scopes**: `invoice-adjustments:write`

        :param create_invoice_adjustment_request: InvoiceAdjustment object that needs to be created (required)
        :type create_invoice_adjustment_request: CreateInvoiceAdjustmentRequest
        :param recurring: Add this invoice adjustment as recurring
        :type recurring: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_invoice_adjustment_serialize(
            create_invoice_adjustment_request=create_invoice_adjustment_request,
            recurring=recurring,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateInvoiceAdjustment201Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_invoice_adjustment_with_http_info(
        self,
        create_invoice_adjustment_request: Annotated[CreateInvoiceAdjustmentRequest, Field(description="InvoiceAdjustment object that needs to be created")],
        recurring: Annotated[Optional[StrictStr], Field(description="Add this invoice adjustment as recurring")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateInvoiceAdjustment201Response]:
        """Create an invoice adjustment

        Create an invoice adjustment using this endpoint. For example, you can add a bonus, commission, VAT %, deduction etc. to an invoice.  **Token scopes**: `invoice-adjustments:write`

        :param create_invoice_adjustment_request: InvoiceAdjustment object that needs to be created (required)
        :type create_invoice_adjustment_request: CreateInvoiceAdjustmentRequest
        :param recurring: Add this invoice adjustment as recurring
        :type recurring: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_invoice_adjustment_serialize(
            create_invoice_adjustment_request=create_invoice_adjustment_request,
            recurring=recurring,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateInvoiceAdjustment201Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_invoice_adjustment_without_preload_content(
        self,
        create_invoice_adjustment_request: Annotated[CreateInvoiceAdjustmentRequest, Field(description="InvoiceAdjustment object that needs to be created")],
        recurring: Annotated[Optional[StrictStr], Field(description="Add this invoice adjustment as recurring")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create an invoice adjustment

        Create an invoice adjustment using this endpoint. For example, you can add a bonus, commission, VAT %, deduction etc. to an invoice.  **Token scopes**: `invoice-adjustments:write`

        :param create_invoice_adjustment_request: InvoiceAdjustment object that needs to be created (required)
        :type create_invoice_adjustment_request: CreateInvoiceAdjustmentRequest
        :param recurring: Add this invoice adjustment as recurring
        :type recurring: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_invoice_adjustment_serialize(
            create_invoice_adjustment_request=create_invoice_adjustment_request,
            recurring=recurring,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateInvoiceAdjustment201Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_invoice_adjustment_serialize(
        self,
        create_invoice_adjustment_request,
        recurring,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if recurring is not None:
            
            _query_params.append(('recurring', recurring))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_invoice_adjustment_request is not None:
            _body_params = create_invoice_adjustment_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'deelToken', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/invoice-adjustments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_invoice_adjustment_reviews(
        self,
        invoice_adjustment_reviews_to_create_container: Annotated[Optional[InvoiceAdjustmentReviewsToCreateContainer], Field(description="InvoiceAdjustment review objects that need to be created")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GenericResultCreated:
        """Bulk review invoice adjustments

        Review multiple invoice adjustments to approve or decline a batch.

        :param invoice_adjustment_reviews_to_create_container: InvoiceAdjustment review objects that need to be created
        :type invoice_adjustment_reviews_to_create_container: InvoiceAdjustmentReviewsToCreateContainer
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_invoice_adjustment_reviews_serialize(
            invoice_adjustment_reviews_to_create_container=invoice_adjustment_reviews_to_create_container,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "GenericResultCreated",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_invoice_adjustment_reviews_with_http_info(
        self,
        invoice_adjustment_reviews_to_create_container: Annotated[Optional[InvoiceAdjustmentReviewsToCreateContainer], Field(description="InvoiceAdjustment review objects that need to be created")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GenericResultCreated]:
        """Bulk review invoice adjustments

        Review multiple invoice adjustments to approve or decline a batch.

        :param invoice_adjustment_reviews_to_create_container: InvoiceAdjustment review objects that need to be created
        :type invoice_adjustment_reviews_to_create_container: InvoiceAdjustmentReviewsToCreateContainer
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_invoice_adjustment_reviews_serialize(
            invoice_adjustment_reviews_to_create_container=invoice_adjustment_reviews_to_create_container,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "GenericResultCreated",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_invoice_adjustment_reviews_without_preload_content(
        self,
        invoice_adjustment_reviews_to_create_container: Annotated[Optional[InvoiceAdjustmentReviewsToCreateContainer], Field(description="InvoiceAdjustment review objects that need to be created")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Bulk review invoice adjustments

        Review multiple invoice adjustments to approve or decline a batch.

        :param invoice_adjustment_reviews_to_create_container: InvoiceAdjustment review objects that need to be created
        :type invoice_adjustment_reviews_to_create_container: InvoiceAdjustmentReviewsToCreateContainer
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_invoice_adjustment_reviews_serialize(
            invoice_adjustment_reviews_to_create_container=invoice_adjustment_reviews_to_create_container,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "GenericResultCreated",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_invoice_adjustment_reviews_serialize(
        self,
        invoice_adjustment_reviews_to_create_container,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if invoice_adjustment_reviews_to_create_container is not None:
            _body_params = invoice_adjustment_reviews_to_create_container


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'deelToken', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/invoice-adjustments/many/reviews',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_invoice_adjustment(
        self,
        id: Annotated[StrictStr, Field(description="Invoice adjustment id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UninviteToSignContract200Response:
        """Delete adjustment

        Delete an adjustment.  **Token scopes**: `invoice-adjustments:write`

        :param id: Invoice adjustment id. (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_invoice_adjustment_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UninviteToSignContract200Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_invoice_adjustment_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Invoice adjustment id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UninviteToSignContract200Response]:
        """Delete adjustment

        Delete an adjustment.  **Token scopes**: `invoice-adjustments:write`

        :param id: Invoice adjustment id. (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_invoice_adjustment_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UninviteToSignContract200Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_invoice_adjustment_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Invoice adjustment id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete adjustment

        Delete an adjustment.  **Token scopes**: `invoice-adjustments:write`

        :param id: Invoice adjustment id. (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_invoice_adjustment_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UninviteToSignContract200Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_invoice_adjustment_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'deelToken', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/invoice-adjustments/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_invoice_adjustments(
        self,
        contract_id: Annotated[Optional[StrictStr], Field(description="Id of an Deel contract.")] = None,
        contract_types: Annotated[Optional[Any], Field(description="types of contracts to filter")] = None,
        types: Annotated[Optional[Any], Field(description="types of invoice adjustments to filter")] = None,
        statuses: Annotated[Optional[Any], Field(description="statuses of invoice adjustment to filter")] = None,
        invoice_id: Annotated[Optional[StrictStr], Field(description="ID of an existing invoice")] = None,
        reporter_id: Annotated[Optional[StrictStr], Field(description="ID of an existing profile")] = None,
        date_from: Annotated[Optional[date], Field(description="To get invoice adjustments submitted on or after given start date (inclusive). Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.")] = None,
        date_to: Annotated[Optional[date], Field(description="To get invoice adjustments submitted before given end date (excludes records submitted on this date). Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.")] = None,
        limit: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Return a page of results with given number of records; NOTE: technically ALL query parameters are strings or array of strings")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="Return a page of results after given index of row; NOTE: technically ALL query parameters are strings or array of strings")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetInvoiceAdjustments200Response:
        """List invoice adjustments

        Retrieve invoice adjustments. You can filter the list by providing additional parameters e.g. contract_id, contract_type etc.  **Token scopes**: `invoice-adjustments:read`

        :param contract_id: Id of an Deel contract.
        :type contract_id: str
        :param contract_types: types of contracts to filter
        :type contract_types: GetTimesheetsByContractContractTypesParameter
        :param types: types of invoice adjustments to filter
        :type types: GetInvoiceAdjustmentsByContractIdTypesParameter
        :param statuses: statuses of invoice adjustment to filter
        :type statuses: GetTimesheetsStatusesParameter
        :param invoice_id: ID of an existing invoice
        :type invoice_id: str
        :param reporter_id: ID of an existing profile
        :type reporter_id: str
        :param date_from: To get invoice adjustments submitted on or after given start date (inclusive). Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.
        :type date_from: date
        :param date_to: To get invoice adjustments submitted before given end date (excludes records submitted on this date). Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.
        :type date_to: date
        :param limit: Return a page of results with given number of records; NOTE: technically ALL query parameters are strings or array of strings
        :type limit: str
        :param offset: Return a page of results after given index of row; NOTE: technically ALL query parameters are strings or array of strings
        :type offset: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_invoice_adjustments_serialize(
            contract_id=contract_id,
            contract_types=contract_types,
            types=types,
            statuses=statuses,
            invoice_id=invoice_id,
            reporter_id=reporter_id,
            date_from=date_from,
            date_to=date_to,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInvoiceAdjustments200Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_invoice_adjustments_with_http_info(
        self,
        contract_id: Annotated[Optional[StrictStr], Field(description="Id of an Deel contract.")] = None,
        contract_types: Annotated[Optional[Any], Field(description="types of contracts to filter")] = None,
        types: Annotated[Optional[Any], Field(description="types of invoice adjustments to filter")] = None,
        statuses: Annotated[Optional[Any], Field(description="statuses of invoice adjustment to filter")] = None,
        invoice_id: Annotated[Optional[StrictStr], Field(description="ID of an existing invoice")] = None,
        reporter_id: Annotated[Optional[StrictStr], Field(description="ID of an existing profile")] = None,
        date_from: Annotated[Optional[date], Field(description="To get invoice adjustments submitted on or after given start date (inclusive). Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.")] = None,
        date_to: Annotated[Optional[date], Field(description="To get invoice adjustments submitted before given end date (excludes records submitted on this date). Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.")] = None,
        limit: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Return a page of results with given number of records; NOTE: technically ALL query parameters are strings or array of strings")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="Return a page of results after given index of row; NOTE: technically ALL query parameters are strings or array of strings")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetInvoiceAdjustments200Response]:
        """List invoice adjustments

        Retrieve invoice adjustments. You can filter the list by providing additional parameters e.g. contract_id, contract_type etc.  **Token scopes**: `invoice-adjustments:read`

        :param contract_id: Id of an Deel contract.
        :type contract_id: str
        :param contract_types: types of contracts to filter
        :type contract_types: GetTimesheetsByContractContractTypesParameter
        :param types: types of invoice adjustments to filter
        :type types: GetInvoiceAdjustmentsByContractIdTypesParameter
        :param statuses: statuses of invoice adjustment to filter
        :type statuses: GetTimesheetsStatusesParameter
        :param invoice_id: ID of an existing invoice
        :type invoice_id: str
        :param reporter_id: ID of an existing profile
        :type reporter_id: str
        :param date_from: To get invoice adjustments submitted on or after given start date (inclusive). Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.
        :type date_from: date
        :param date_to: To get invoice adjustments submitted before given end date (excludes records submitted on this date). Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.
        :type date_to: date
        :param limit: Return a page of results with given number of records; NOTE: technically ALL query parameters are strings or array of strings
        :type limit: str
        :param offset: Return a page of results after given index of row; NOTE: technically ALL query parameters are strings or array of strings
        :type offset: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_invoice_adjustments_serialize(
            contract_id=contract_id,
            contract_types=contract_types,
            types=types,
            statuses=statuses,
            invoice_id=invoice_id,
            reporter_id=reporter_id,
            date_from=date_from,
            date_to=date_to,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInvoiceAdjustments200Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_invoice_adjustments_without_preload_content(
        self,
        contract_id: Annotated[Optional[StrictStr], Field(description="Id of an Deel contract.")] = None,
        contract_types: Annotated[Optional[Any], Field(description="types of contracts to filter")] = None,
        types: Annotated[Optional[Any], Field(description="types of invoice adjustments to filter")] = None,
        statuses: Annotated[Optional[Any], Field(description="statuses of invoice adjustment to filter")] = None,
        invoice_id: Annotated[Optional[StrictStr], Field(description="ID of an existing invoice")] = None,
        reporter_id: Annotated[Optional[StrictStr], Field(description="ID of an existing profile")] = None,
        date_from: Annotated[Optional[date], Field(description="To get invoice adjustments submitted on or after given start date (inclusive). Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.")] = None,
        date_to: Annotated[Optional[date], Field(description="To get invoice adjustments submitted before given end date (excludes records submitted on this date). Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.")] = None,
        limit: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Return a page of results with given number of records; NOTE: technically ALL query parameters are strings or array of strings")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="Return a page of results after given index of row; NOTE: technically ALL query parameters are strings or array of strings")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List invoice adjustments

        Retrieve invoice adjustments. You can filter the list by providing additional parameters e.g. contract_id, contract_type etc.  **Token scopes**: `invoice-adjustments:read`

        :param contract_id: Id of an Deel contract.
        :type contract_id: str
        :param contract_types: types of contracts to filter
        :type contract_types: GetTimesheetsByContractContractTypesParameter
        :param types: types of invoice adjustments to filter
        :type types: GetInvoiceAdjustmentsByContractIdTypesParameter
        :param statuses: statuses of invoice adjustment to filter
        :type statuses: GetTimesheetsStatusesParameter
        :param invoice_id: ID of an existing invoice
        :type invoice_id: str
        :param reporter_id: ID of an existing profile
        :type reporter_id: str
        :param date_from: To get invoice adjustments submitted on or after given start date (inclusive). Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.
        :type date_from: date
        :param date_to: To get invoice adjustments submitted before given end date (excludes records submitted on this date). Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.
        :type date_to: date
        :param limit: Return a page of results with given number of records; NOTE: technically ALL query parameters are strings or array of strings
        :type limit: str
        :param offset: Return a page of results after given index of row; NOTE: technically ALL query parameters are strings or array of strings
        :type offset: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_invoice_adjustments_serialize(
            contract_id=contract_id,
            contract_types=contract_types,
            types=types,
            statuses=statuses,
            invoice_id=invoice_id,
            reporter_id=reporter_id,
            date_from=date_from,
            date_to=date_to,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInvoiceAdjustments200Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_invoice_adjustments_serialize(
        self,
        contract_id,
        contract_types,
        types,
        statuses,
        invoice_id,
        reporter_id,
        date_from,
        date_to,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if contract_id is not None:
            
            _query_params.append(('contract_id', contract_id))
            
        if contract_types is not None:
            
            _query_params.append(('contract_types', contract_types))
            
        if types is not None:
            
            _query_params.append(('types', types))
            
        if statuses is not None:
            
            _query_params.append(('statuses', statuses))
            
        if invoice_id is not None:
            
            _query_params.append(('invoice_id', invoice_id))
            
        if reporter_id is not None:
            
            _query_params.append(('reporter_id', reporter_id))
            
        if date_from is not None:
            if isinstance(date_from, date):
                _query_params.append(
                    (
                        'date_from',
                        date_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date_from', date_from))
            
        if date_to is not None:
            if isinstance(date_to, date):
                _query_params.append(
                    (
                        'date_to',
                        date_to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date_to', date_to))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'deelToken', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoice-adjustments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_invoice_adjustments_by_contract_id(
        self,
        contract_id: Annotated[StrictStr, Field(description="Deel contract id.")],
        contract_types: Annotated[Optional[Any], Field(description="types of contracts to filter")] = None,
        types: Annotated[Optional[Any], Field(description="types of invoice adjustments to filter")] = None,
        statuses: Annotated[Optional[Any], Field(description="statuses of invoice adjustment to filter")] = None,
        invoice_id: Annotated[Optional[StrictStr], Field(description="ID of an existing invoice")] = None,
        reporter_id: Annotated[Optional[StrictStr], Field(description="ID of an existing profile")] = None,
        date_from: Annotated[Optional[date], Field(description="To get invoice adjustments submitted on or after given start date (inclusive).    Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.")] = None,
        date_to: Annotated[Optional[date], Field(description="To get invoice adjustments submitted before given end date (excludes records submitted on this date).    Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.")] = None,
        limit: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Return a page of results with given number of records; NOTE: technically ALL query parameters are strings or array of strings")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="Return a page of results after given index of row; NOTE: technically ALL query parameters are strings or array of strings")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetInvoiceAdjustmentsByContractId200Response:
        """Invoice line items by contract

        Retrieve invoice line items for a given contract id.  **Token scopes**: `invoice-adjustments:read`

        :param contract_id: Deel contract id. (required)
        :type contract_id: str
        :param contract_types: types of contracts to filter
        :type contract_types: GetTimesheetsByContractContractTypesParameter
        :param types: types of invoice adjustments to filter
        :type types: GetInvoiceAdjustmentsByContractIdTypesParameter
        :param statuses: statuses of invoice adjustment to filter
        :type statuses: GetTimesheetsStatusesParameter
        :param invoice_id: ID of an existing invoice
        :type invoice_id: str
        :param reporter_id: ID of an existing profile
        :type reporter_id: str
        :param date_from: To get invoice adjustments submitted on or after given start date (inclusive).    Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.
        :type date_from: date
        :param date_to: To get invoice adjustments submitted before given end date (excludes records submitted on this date).    Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.
        :type date_to: date
        :param limit: Return a page of results with given number of records; NOTE: technically ALL query parameters are strings or array of strings
        :type limit: str
        :param offset: Return a page of results after given index of row; NOTE: technically ALL query parameters are strings or array of strings
        :type offset: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_invoice_adjustments_by_contract_id_serialize(
            contract_id=contract_id,
            contract_types=contract_types,
            types=types,
            statuses=statuses,
            invoice_id=invoice_id,
            reporter_id=reporter_id,
            date_from=date_from,
            date_to=date_to,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInvoiceAdjustmentsByContractId200Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_invoice_adjustments_by_contract_id_with_http_info(
        self,
        contract_id: Annotated[StrictStr, Field(description="Deel contract id.")],
        contract_types: Annotated[Optional[Any], Field(description="types of contracts to filter")] = None,
        types: Annotated[Optional[Any], Field(description="types of invoice adjustments to filter")] = None,
        statuses: Annotated[Optional[Any], Field(description="statuses of invoice adjustment to filter")] = None,
        invoice_id: Annotated[Optional[StrictStr], Field(description="ID of an existing invoice")] = None,
        reporter_id: Annotated[Optional[StrictStr], Field(description="ID of an existing profile")] = None,
        date_from: Annotated[Optional[date], Field(description="To get invoice adjustments submitted on or after given start date (inclusive).    Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.")] = None,
        date_to: Annotated[Optional[date], Field(description="To get invoice adjustments submitted before given end date (excludes records submitted on this date).    Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.")] = None,
        limit: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Return a page of results with given number of records; NOTE: technically ALL query parameters are strings or array of strings")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="Return a page of results after given index of row; NOTE: technically ALL query parameters are strings or array of strings")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetInvoiceAdjustmentsByContractId200Response]:
        """Invoice line items by contract

        Retrieve invoice line items for a given contract id.  **Token scopes**: `invoice-adjustments:read`

        :param contract_id: Deel contract id. (required)
        :type contract_id: str
        :param contract_types: types of contracts to filter
        :type contract_types: GetTimesheetsByContractContractTypesParameter
        :param types: types of invoice adjustments to filter
        :type types: GetInvoiceAdjustmentsByContractIdTypesParameter
        :param statuses: statuses of invoice adjustment to filter
        :type statuses: GetTimesheetsStatusesParameter
        :param invoice_id: ID of an existing invoice
        :type invoice_id: str
        :param reporter_id: ID of an existing profile
        :type reporter_id: str
        :param date_from: To get invoice adjustments submitted on or after given start date (inclusive).    Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.
        :type date_from: date
        :param date_to: To get invoice adjustments submitted before given end date (excludes records submitted on this date).    Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.
        :type date_to: date
        :param limit: Return a page of results with given number of records; NOTE: technically ALL query parameters are strings or array of strings
        :type limit: str
        :param offset: Return a page of results after given index of row; NOTE: technically ALL query parameters are strings or array of strings
        :type offset: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_invoice_adjustments_by_contract_id_serialize(
            contract_id=contract_id,
            contract_types=contract_types,
            types=types,
            statuses=statuses,
            invoice_id=invoice_id,
            reporter_id=reporter_id,
            date_from=date_from,
            date_to=date_to,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInvoiceAdjustmentsByContractId200Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_invoice_adjustments_by_contract_id_without_preload_content(
        self,
        contract_id: Annotated[StrictStr, Field(description="Deel contract id.")],
        contract_types: Annotated[Optional[Any], Field(description="types of contracts to filter")] = None,
        types: Annotated[Optional[Any], Field(description="types of invoice adjustments to filter")] = None,
        statuses: Annotated[Optional[Any], Field(description="statuses of invoice adjustment to filter")] = None,
        invoice_id: Annotated[Optional[StrictStr], Field(description="ID of an existing invoice")] = None,
        reporter_id: Annotated[Optional[StrictStr], Field(description="ID of an existing profile")] = None,
        date_from: Annotated[Optional[date], Field(description="To get invoice adjustments submitted on or after given start date (inclusive).    Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.")] = None,
        date_to: Annotated[Optional[date], Field(description="To get invoice adjustments submitted before given end date (excludes records submitted on this date).    Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.")] = None,
        limit: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Return a page of results with given number of records; NOTE: technically ALL query parameters are strings or array of strings")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="Return a page of results after given index of row; NOTE: technically ALL query parameters are strings or array of strings")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Invoice line items by contract

        Retrieve invoice line items for a given contract id.  **Token scopes**: `invoice-adjustments:read`

        :param contract_id: Deel contract id. (required)
        :type contract_id: str
        :param contract_types: types of contracts to filter
        :type contract_types: GetTimesheetsByContractContractTypesParameter
        :param types: types of invoice adjustments to filter
        :type types: GetInvoiceAdjustmentsByContractIdTypesParameter
        :param statuses: statuses of invoice adjustment to filter
        :type statuses: GetTimesheetsStatusesParameter
        :param invoice_id: ID of an existing invoice
        :type invoice_id: str
        :param reporter_id: ID of an existing profile
        :type reporter_id: str
        :param date_from: To get invoice adjustments submitted on or after given start date (inclusive).    Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.
        :type date_from: date
        :param date_to: To get invoice adjustments submitted before given end date (excludes records submitted on this date).    Short date in format ISO-8601 (YYYY-MM-DD). For example: 2022-12-31.
        :type date_to: date
        :param limit: Return a page of results with given number of records; NOTE: technically ALL query parameters are strings or array of strings
        :type limit: str
        :param offset: Return a page of results after given index of row; NOTE: technically ALL query parameters are strings or array of strings
        :type offset: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_invoice_adjustments_by_contract_id_serialize(
            contract_id=contract_id,
            contract_types=contract_types,
            types=types,
            statuses=statuses,
            invoice_id=invoice_id,
            reporter_id=reporter_id,
            date_from=date_from,
            date_to=date_to,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInvoiceAdjustmentsByContractId200Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_invoice_adjustments_by_contract_id_serialize(
        self,
        contract_id,
        contract_types,
        types,
        statuses,
        invoice_id,
        reporter_id,
        date_from,
        date_to,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if contract_id is not None:
            _path_params['contract_id'] = contract_id
        # process the query parameters
        if contract_types is not None:
            
            _query_params.append(('contract_types', contract_types))
            
        if types is not None:
            
            _query_params.append(('types', types))
            
        if statuses is not None:
            
            _query_params.append(('statuses', statuses))
            
        if invoice_id is not None:
            
            _query_params.append(('invoice_id', invoice_id))
            
        if reporter_id is not None:
            
            _query_params.append(('reporter_id', reporter_id))
            
        if date_from is not None:
            if isinstance(date_from, date):
                _query_params.append(
                    (
                        'date_from',
                        date_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date_from', date_from))
            
        if date_to is not None:
            if isinstance(date_to, date):
                _query_params.append(
                    (
                        'date_to',
                        date_to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date_to', date_to))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'deelToken', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contracts/{contract_id}/invoice-adjustments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_invoice_adjustments_by_id(
        self,
        id: Annotated[StrictStr, Field(description="ID of an existing invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetInvoiceAdjustmentsById200Response:
        """Invoice line item by Id

        Retrieve invoice line item for a given id.  **Token scopes**: `invoice-adjustments:read`

        :param id: ID of an existing invoice (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_invoice_adjustments_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInvoiceAdjustmentsById200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_invoice_adjustments_by_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="ID of an existing invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetInvoiceAdjustmentsById200Response]:
        """Invoice line item by Id

        Retrieve invoice line item for a given id.  **Token scopes**: `invoice-adjustments:read`

        :param id: ID of an existing invoice (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_invoice_adjustments_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInvoiceAdjustmentsById200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_invoice_adjustments_by_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="ID of an existing invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Invoice line item by Id

        Retrieve invoice line item for a given id.  **Token scopes**: `invoice-adjustments:read`

        :param id: ID of an existing invoice (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_invoice_adjustments_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInvoiceAdjustmentsById200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_invoice_adjustments_by_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'deelToken', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoice-adjustments/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_invoice_adjustment(
        self,
        id: Annotated[StrictStr, Field(description="Invoice adjustment id.")],
        update_invoice_adjustment_request: UpdateInvoiceAdjustmentRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UpdateInvoiceAdjustment200Response:
        """Update an invoice adjustment

        Update an invoice adjustment.  **Token scopes**: `invoice-adjustments:write`

        :param id: Invoice adjustment id. (required)
        :type id: str
        :param update_invoice_adjustment_request: (required)
        :type update_invoice_adjustment_request: UpdateInvoiceAdjustmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_invoice_adjustment_serialize(
            id=id,
            update_invoice_adjustment_request=update_invoice_adjustment_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateInvoiceAdjustment200Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_invoice_adjustment_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Invoice adjustment id.")],
        update_invoice_adjustment_request: UpdateInvoiceAdjustmentRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UpdateInvoiceAdjustment200Response]:
        """Update an invoice adjustment

        Update an invoice adjustment.  **Token scopes**: `invoice-adjustments:write`

        :param id: Invoice adjustment id. (required)
        :type id: str
        :param update_invoice_adjustment_request: (required)
        :type update_invoice_adjustment_request: UpdateInvoiceAdjustmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_invoice_adjustment_serialize(
            id=id,
            update_invoice_adjustment_request=update_invoice_adjustment_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateInvoiceAdjustment200Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_invoice_adjustment_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Invoice adjustment id.")],
        update_invoice_adjustment_request: UpdateInvoiceAdjustmentRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update an invoice adjustment

        Update an invoice adjustment.  **Token scopes**: `invoice-adjustments:write`

        :param id: Invoice adjustment id. (required)
        :type id: str
        :param update_invoice_adjustment_request: (required)
        :type update_invoice_adjustment_request: UpdateInvoiceAdjustmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_invoice_adjustment_serialize(
            id=id,
            update_invoice_adjustment_request=update_invoice_adjustment_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateInvoiceAdjustment200Response",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_invoice_adjustment_serialize(
        self,
        id,
        update_invoice_adjustment_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_invoice_adjustment_request is not None:
            _body_params = update_invoice_adjustment_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'deelToken', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/invoice-adjustments/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_invoice_adjustment_by_id(
        self,
        id: Annotated[StrictStr, Field(description="ID of an existing invoice adjustment.")],
        update_invoice_adjustment_by_id_request: UpdateInvoiceAdjustmentByIdRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UpdateAdjustment200Response:
        """Review an invoice adjustment

        Review an existing invoice adjustment to approve or reject it. It is not possible to update VAT adjustments, we recommend you to delete the existing VAT adjust and create a new one.  **Token scopes**: `invoice-adjustments:write`

        :param id: ID of an existing invoice adjustment. (required)
        :type id: str
        :param update_invoice_adjustment_by_id_request: (required)
        :type update_invoice_adjustment_by_id_request: UpdateInvoiceAdjustmentByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_invoice_adjustment_by_id_serialize(
            id=id,
            update_invoice_adjustment_by_id_request=update_invoice_adjustment_by_id_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateAdjustment200Response",
            '201': "GenericResultCreated",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_invoice_adjustment_by_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="ID of an existing invoice adjustment.")],
        update_invoice_adjustment_by_id_request: UpdateInvoiceAdjustmentByIdRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UpdateAdjustment200Response]:
        """Review an invoice adjustment

        Review an existing invoice adjustment to approve or reject it. It is not possible to update VAT adjustments, we recommend you to delete the existing VAT adjust and create a new one.  **Token scopes**: `invoice-adjustments:write`

        :param id: ID of an existing invoice adjustment. (required)
        :type id: str
        :param update_invoice_adjustment_by_id_request: (required)
        :type update_invoice_adjustment_by_id_request: UpdateInvoiceAdjustmentByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_invoice_adjustment_by_id_serialize(
            id=id,
            update_invoice_adjustment_by_id_request=update_invoice_adjustment_by_id_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateAdjustment200Response",
            '201': "GenericResultCreated",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_invoice_adjustment_by_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="ID of an existing invoice adjustment.")],
        update_invoice_adjustment_by_id_request: UpdateInvoiceAdjustmentByIdRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Review an invoice adjustment

        Review an existing invoice adjustment to approve or reject it. It is not possible to update VAT adjustments, we recommend you to delete the existing VAT adjust and create a new one.  **Token scopes**: `invoice-adjustments:write`

        :param id: ID of an existing invoice adjustment. (required)
        :type id: str
        :param update_invoice_adjustment_by_id_request: (required)
        :type update_invoice_adjustment_by_id_request: UpdateInvoiceAdjustmentByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_invoice_adjustment_by_id_serialize(
            id=id,
            update_invoice_adjustment_by_id_request=update_invoice_adjustment_by_id_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateAdjustment200Response",
            '201': "GenericResultCreated",
            '400': "ApiErrorContainer",
            '401': "ApiErrorContainer",
            '403': "ApiErrorContainer",
            '404': "ApiErrorContainer",
            '405': "ApiErrorContainer",
            '429': "ApiErrorContainer",
            '500': "ApiErrorContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_invoice_adjustment_by_id_serialize(
        self,
        id,
        update_invoice_adjustment_by_id_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_invoice_adjustment_by_id_request is not None:
            _body_params = update_invoice_adjustment_by_id_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'deelToken', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/invoice-adjustments/{id}/reviews',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


