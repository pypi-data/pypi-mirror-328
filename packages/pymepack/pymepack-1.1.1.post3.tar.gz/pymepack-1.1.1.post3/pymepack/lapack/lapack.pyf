!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module lapack ! in 
    interface  ! in :lapack
        subroutine dggbal(job,n,a,lda,b,ldb,ilo,ihi,lscale,rscale,work,info) ! in dggbal.f
            character :: job
            integer :: n
            double precision intent(in,out,copy),dimension(lda,*) :: a
            integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
            double precision intent(in,out,copy),dimension(ldb,*) :: b
            integer, optional,check(shape(b, 0) == ldb),depend(b) :: ldb=shape(b, 0)
            integer intent(out):: ilo
            integer intent(out):: ihi
            double precision dimension(*) :: lscale
            double precision dimension(*) :: rscale
            double precision dimension(*) :: work
            integer intent(out):: info
        end subroutine dggbal
        subroutine sggbal(job,n,a,lda,b,ldb,ilo,ihi,lscale,rscale,work,info) ! in sggbal.f
            character :: job
            integer :: n
            real intent(in,out,copy),dimension(lda,*) :: a
            integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
            real intent(in,out,copy),dimension(ldb,*) :: b
            integer, optional,check(shape(b, 0) == ldb),depend(b) :: ldb=shape(b, 0)
            integer intent(out):: ilo
            integer intent(out):: ihi
            real dimension(*) :: lscale
            real dimension(*) :: rscale
            real dimension(*) :: work
            integer intent(out):: info
        end subroutine sggbal
        subroutine dgghrd(compq,compz,n,ilo,ihi,a,lda,b,ldb,q,ldq,z,ldz,info) ! in dgghrd.f
            character :: compq
            character :: compz
            integer :: n
            integer :: ilo
            integer :: ihi
            double precision intent(in,out,copy),dimension(lda,*) :: a
            integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
            double precision intent(in,out,copy),dimension(ldb,*) :: b
            integer, optional,check(shape(b, 0) == ldb),depend(b) :: ldb=shape(b, 0)
            double precision intent(in,out,copy),dimension(ldq,*) :: q
            integer, optional,check(shape(q, 0) == ldq),depend(q) :: ldq=shape(q, 0)
            double precision intent(in,out,copy),dimension(ldz,*) :: z
            integer, optional,check(shape(z, 0) == ldz),depend(z) :: ldz=shape(z, 0)
            integer intent(out):: info
        end subroutine dgghrd
        subroutine sgghrd(compq,compz,n,ilo,ihi,a,lda,b,ldb,q,ldq,z,ldz,info) ! in sgghrd.f
            character :: compq
            character :: compz
            integer :: n
            integer :: ilo
            integer :: ihi
            real intent(in,out,copy),dimension(lda,*) :: a
            integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
            real intent(in,out,copy),dimension(ldb,*) :: b
            integer, optional,check(shape(b, 0) == ldb),depend(b) :: ldb=shape(b, 0)
            real intent(in,out,copy),dimension(ldq,*) :: q
            integer, optional,check(shape(q, 0) == ldq),depend(q) :: ldq=shape(q, 0)
            real intent(in,out,copy),dimension(ldz,*) :: z
            integer, optional,check(shape(z, 0) == ldz),depend(z) :: ldz=shape(z, 0)
            integer intent(out):: info
        end subroutine sgghrd
        subroutine dorgqr(m,n,k,a,lda,tau,work,lwork,info) ! in dorgqr.f
            integer :: m
            integer :: n
            integer :: k
            double precision intent(in,out,copy),dimension(lda,*) :: a
            integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
            double precision intent(in),dimension(*) :: tau
            double precision intent(in),dimension(*) :: work
            integer :: lwork
            integer intent(out):: info
        end subroutine dorgqr
        subroutine sorgqr(m,n,k,a,lda,tau,work,lwork,info) ! in sorgqr.f
            integer :: m
            integer :: n
            integer :: k
            real intent(in,out,copy),dimension(lda,*) :: a
            integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
            real intent(in),dimension(*) :: tau
            real intent(in),dimension(*) :: work
            integer :: lwork
            integer intent(out):: info
        end subroutine sorgqr
        subroutine dormqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info) ! in dormqr.f
            character :: side
            character :: trans
            integer :: m
            integer :: n
            integer :: k
            double precision intent(in),dimension(lda,*) :: a
            integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
            double precision intent(in),dimension(*) :: tau
            double precision intent(in,out,copy),dimension(ldc,*) :: c
            integer, optional,check(shape(c, 0) == ldc),depend(c) :: ldc=shape(c, 0)
            double precision intent(in),dimension(*) :: work
            integer intent(in):: lwork
            integer intent(out):: info
        end subroutine dormqr
        subroutine sormqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info) ! in sormqr.f
            character :: side
            character :: trans
            integer :: m
            integer :: n
            integer :: k
            real intent(in),dimension(lda,*) :: a
            integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
            real intent(in),dimension(*) :: tau
            real intent(in,out,copy),dimension(ldc,*) :: c
            integer, optional,check(shape(c, 0) == ldc),depend(c) :: ldc=shape(c, 0)
            real intent(in),dimension(*) :: work
            integer intent(in):: lwork
            integer intent(out):: info
        end subroutine sormqr
    end interface 
end python module lapack

! This file was auto-generated with f2py (version:1.26.0).
! See:
! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e
