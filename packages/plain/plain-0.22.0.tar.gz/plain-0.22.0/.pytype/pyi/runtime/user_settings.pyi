# (generated with --quick)

import importlib
import json
import os
import pathlib
import time
import types
import typing
from typing import Any, Optional, TypeVar

CUSTOM_SETTINGS_PREFIX: str
ENVIRONMENT_VARIABLE: str
ENV_SETTINGS_PREFIX: str
ImproperlyConfigured: Any
PackageConfig: Any
Path: type[pathlib.Path]

_TSettingsReference = TypeVar('_TSettingsReference', bound=SettingsReference)

class SettingDefinition:
    __doc__: str
    annotation: Any
    default_value: Any
    is_set: bool
    module: Any
    name: Any
    required: Any
    source: Any
    value: Any
    def __init__(self, name, default_value = ..., annotation = ..., module = ..., required = ...) -> None: ...
    def __str__(self) -> str: ...
    @staticmethod
    def _is_instance_of_type(value, type_hint) -> bool: ...
    def check_type(self, obj) -> None: ...
    def set_value(self, value, source) -> None: ...

class Settings:
    __doc__: str
    _errors: list[str]
    _settings: dict[Any, SettingDefinition]
    _settings_module: Any
    configured: bool
    path: pathlib.Path
    def __getattr__(self, name) -> Any: ...
    def __init__(self, settings_module = ...) -> None: ...
    def __repr__(self) -> str: ...
    def __setattr__(self, name, value) -> None: ...
    def _check_required_settings(self) -> None: ...
    def _load_default_settings(self, settings_module) -> None: ...
    def _load_env_settings(self) -> None: ...
    def _load_explicit_settings(self, settings_module) -> None: ...
    def _load_module_settings(self, module) -> None: ...
    def _raise_errors_if_any(self) -> None: ...
    def _setup(self) -> None: ...

class SettingsReference(str):
    __doc__: str
    setting_name: Any
    def __init__(self, value, setting_name) -> None: ...
    def __new__(self: type[_TSettingsReference], value, setting_name) -> _TSettingsReference: ...

def _parse_env_value(value, annotation) -> Any: ...
def find_spec(name: str, package: Optional[str] = ...) -> Optional[importlib.machinery.ModuleSpec]: ...
