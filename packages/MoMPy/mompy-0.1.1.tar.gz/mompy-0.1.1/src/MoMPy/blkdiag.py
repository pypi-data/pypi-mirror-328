#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Feb  5 14:32:37 2025

@author: carles
"""


def M_ones(matrix,element,eps):
    
    """
    Identifies elements eps-equivalent to a chosen value and
    returns another matrix with ones in those slots
    """
    
    output = np.zeros((len(matrix),len(matrix)))
    
    for i in range(len(matrix)):
        for j in range(len(matrix)):
            if i >= j:
                if np.abs(matrix[i][j]-element) <= eps:
                    output[i][j] = 1
                    output[j][i] = 1 # For symmetric matrices
    
    return output

def blkdiag(MomMat,id_els):
    
    """
    Block-diagonalize a given moment matrix  "MomMat" with identical elements 
    listed in "id_els"
    """
    
    threshold = 1e-3
    n = len(MomMat[0])	
    m = len(id_els)
    
    A = []
    for i in range(len(id_els)):
        A += [ M_ones(MomMat,id_els[i],1e-5) ]

    # B is a random self-adjoint matrix generated by matrices from A (and their conjugate transposes)
    B = np.zeros((n,n))
    for p in range(m):
   		B = B + np.random.normal()*(A[p]+A[p].transpose())

    # find the eigenvalues and eigenvectors of B
    D, V = np.linalg.eigh(B)

    # C is a matrix used to sort the column vectors of V (i.e., the base vectors)
    # such that the base vectors corresponding to the same common block are next to each other
    C = np.zeros((n,n))
    for p in range(m):
        C = C + np.random.normal()*(A[p]+A[p].transpose())
    C = V.transpose()@C@V

    # arrays used to track which base vectors have been sorted
    remaining_basis = list(range(n))
    sorted_basis = []

    ListBlocks = []	# initialize the array that lists the size of each common block

    # the sorting process: find C_ij's that are nonzero and group the base vectors v_i and v_j together
    while len(remaining_basis) > 0:
        current_block = [remaining_basis[0]]
        current_block_size = 1
        if len(remaining_basis) > 1:
            for idx in remaining_basis[1:]:
                if np.abs(C[remaining_basis[0],idx]) > threshold:
                    current_block.append(idx)
                    current_block_size = current_block_size + 1

        for idx in current_block:
            sorted_basis.append(idx)
            remaining_basis.remove(idx)

		# do the following in case there are zero entries inside the block
        current_block_extra = []
        if len(remaining_basis) > 0:
            for idx in remaining_basis:
                for ind in current_block:
                    if np.abs(C[ind,idx]) > threshold:
                        current_block_extra.append(idx)
                        current_block_size = current_block_size + 1
                        break

        for idx in current_block_extra:
            sorted_basis.append(idx)
            remaining_basis.remove(idx)

        ListBlocks.append(current_block_size)
    
    # the sorted base vectors give the final orthogonal/unitary transformation matrix that performs SBD on A
    Trans = V[:,sorted_basis]

    P = []
    for i in range(len(id_els)):
        P += [ Trans.T @ A[i] @ Trans ]
        
        
    """ 
    OUTPUTS
        Trans: Transformation to block-diagonalize the SDP
        ListBlocks: List of blocks in the block-diagonalized space
        P: Matrices identifying where each element in id_els is, but in the block-diagonalized space
    """
            
    return Trans, ListBlocks, P






