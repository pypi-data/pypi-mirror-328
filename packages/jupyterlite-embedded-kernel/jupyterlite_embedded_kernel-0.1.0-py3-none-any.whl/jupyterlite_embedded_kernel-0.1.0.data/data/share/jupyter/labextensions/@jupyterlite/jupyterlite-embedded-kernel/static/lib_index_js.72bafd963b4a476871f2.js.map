{"version":3,"file":"lib_index_js.72bafd963b4a476871f2.js","mappings":";;;;;;;;;;;;;;;;AAAmD;AACb;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;AACA,sDAAsD,aAAa;AACnE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,mCAAmC,+CAAU;AAC7C;AACA;AACA;AACA;AACA;AACA,0CAA0C,kBAAkB;AAC5D;AACA,gDAAgD,0BAA0B;AAC1E;AACA,gDAAgD,yBAAyB;AACzE;AACA,6CAA6C,kBAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;ACtE0B;AACjD;AACA;AACA;AACO,yBAAyB,2DAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,kCAAkC;AAClC;AACA;AACA,iDAAiD;AACjD;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://jupyterlite_embedded_kernel/./lib/index.js","webpack://jupyterlite_embedded_kernel/./lib/kernel.js"],"sourcesContent":["import { IKernelSpecs } from '@jupyterlite/kernel';\nimport { EchoKernel } from './kernel';\n/**\n * Plugin configuration for the enhanced kernel\n */\nconst enhancedKernel = {\n    id: 'enhanced-kernel-plugin',\n    autoStart: true,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        const activeKernels = new Map();\n        app.router.post('/api/kernels/(.*)/interrupt', async (req, kernelId) => {\n            const kernel = activeKernels.get(kernelId);\n            if (kernel) {\n                try {\n                    await kernel.interrupt();\n                    return new Response(null, { status: 204 });\n                }\n                catch (error) {\n                    console.error('Failed to interrupt kernel:', error);\n                    return new Response('Failed to interrupt kernel', { status: 500 });\n                }\n            }\n            return new Response('Kernel not found', { status: 404 });\n        });\n        kernelspecs.register({\n            spec: {\n                name: 'enhanced',\n                display_name: 'Enhanced Kernel',\n                language: 'python',\n                argv: [],\n                resources: {\n                    'logo-32x32': '',\n                    'logo-64x64': '',\n                },\n            },\n            create: async (options) => {\n                const kernel = new EchoKernel(options);\n                activeKernels.set(kernel.id, kernel);\n                async function connectSerialPort() {\n                    var _a, _b;\n                    try {\n                        const port = await navigator.serial.requestPort();\n                        await port.open({ baudRate: 115200 });\n                        //\n                        await port.setSignals({ dataTerminalReady: false });\n                        await new Promise((resolve) => setTimeout(resolve, 200));\n                        await port.setSignals({ dataTerminalReady: true });\n                        //\n                        // await port.open({ baudRate: 115200 });\n                        const reader = (_a = port.readable) === null || _a === void 0 ? void 0 : _a.getReader();\n                        const writer = (_b = port.writable) === null || _b === void 0 ? void 0 : _b.getWriter();\n                        kernel.reader = reader;\n                        kernel.writer = writer;\n                        kernel.port = port;\n                    }\n                    catch (err) {\n                        console.error('Serial Port Error:', err);\n                    }\n                }\n                await connectSerialPort();\n                console.log('Creating enhanced kernel instance');\n                await kernel.ready;\n                return kernel;\n            },\n        });\n        console.log('Enhanced kernel plugin activated');\n    },\n};\nconst plugins = [enhancedKernel];\nexport default plugins;\n","import { BaseKernel } from '@jupyterlite/kernel';\n/**\n * A kernel that echos content back.\n */\nexport class EchoKernel extends BaseKernel {\n    constructor() {\n        super(...arguments);\n        this.blocker = null;\n        this.blockerResolve = null;\n        this.first_run = true;\n    }\n    setBlocked(blocked) {\n        if (blocked && !this.blocker) {\n            this.blocker = new Promise((resolve) => {\n                this.blockerResolve = resolve;\n            });\n        }\n        else if (!blocked && this.blockerResolve) {\n            this.blockerResolve();\n            this.blocker = null;\n            this.blockerResolve = null;\n        }\n    }\n    async interrupt() {\n        if (this.writer) {\n            const ctrl_c = new Uint8Array([3]);\n            const encoder = new TextEncoder();\n            const new_line = encoder.encode('\\r\\n');\n            await this.writer.write(ctrl_c);\n            await this.writer.write(new_line);\n        }\n    }\n    streamOutput(output) {\n        this.stream({\n            text: output,\n            name: 'stdout',\n        });\n    }\n    // /*\n    //  * https://github.com/WICG/serial/issues/122\n    //  */\n    async readWithTimeout(timeoutMs = 500) {\n        if (!this.reader) {\n            return null;\n        }\n        const result = await this.reader.read();\n        return result.value;\n    }\n    async read_loop() {\n        let outputBuffer = ''; // Buffer to accumulate data\n        const sendInterval = 500; // Interval in milliseconds to send data\n        const sendData = () => {\n            if (outputBuffer) {\n                this.streamOutput(outputBuffer); // Send accumulated data\n                console.log(outputBuffer);\n                outputBuffer = ''; // Clear the buffer\n            }\n        };\n        const intervalId = setInterval(sendData, sendInterval);\n        try {\n            while (this.reader) {\n                const value = await this.readWithTimeout();\n                if (!value) {\n                    continue;\n                }\n                const data = new TextDecoder().decode(value);\n                console.log('Current buffer before: ', outputBuffer);\n                outputBuffer += data;\n                console.log('Data: ', data);\n                console.log('Current buffer after: ', outputBuffer);\n                if (data.includes('>>>')) {\n                    this.setBlocked(false);\n                }\n            }\n        }\n        finally {\n            clearInterval(intervalId); // Stop the timer when exiting the loop\n            sendData(); // Ensure remaining data is sent\n        }\n    }\n    async waitForPrompt() {\n        if (this.blocker) {\n            await this.blocker;\n        }\n    }\n    // async readUntilError() {\n    //   try {\n    //     while (this.reader) {\n    //       const data  = await this.readWithTimeout();\n    //       if (data){\n    //         const value = new TextDecoder().decode(data);\n    //         this.streamOutput(value)\n    //       }\n    //     }\n    //   } catch (error) {\n    //     console.error(error);\n    //     return\n    //   }\n    // }\n    async kernelInfoRequest() {\n        const content = {\n            implementation: 'embedded',\n            implementation_version: '1.0.0',\n            language_info: {\n                codemirror_mode: {\n                    name: 'python',\n                    version: 3,\n                },\n                file_extension: '.py',\n                mimetype: 'text/x-python',\n                name: 'python',\n                nbconvert_exporter: 'python',\n                pygments_lexer: 'ipython3',\n                version: '3.8',\n            },\n            protocol_version: '5.3',\n            status: 'ok',\n            banner: 'Echo Kernel with Serial Support',\n            help_links: [\n                {\n                    text: 'Echo Kernel',\n                    url: 'https://github.com/jupyterlite/echo-kernel',\n                },\n            ],\n        };\n        return content;\n    }\n    async executeRequest(content) {\n        this.setBlocked(true);\n        if (this.first_run) {\n            this.read_loop();\n            this.first_run = false;\n        }\n        const { code } = content;\n        const encoder = new TextEncoder();\n        // const ctrl_a = new Uint8Array([1])\n        const ctrl_d = new Uint8Array([4]);\n        const ctrl_e = new Uint8Array([5]);\n        const new_line = encoder.encode('\\r\\n');\n        console.log('2');\n        if (this.writer) {\n            await this.writer.write(ctrl_e);\n            await this.writer.write(new_line);\n            const data = encoder.encode(code);\n            await this.writer.write(data);\n            await this.writer.write(ctrl_d);\n            await this.writer.write(new_line);\n        }\n        console.log('3');\n        await this.waitForPrompt();\n        console.log('4');\n        return {\n            status: 'ok',\n            execution_count: this.executionCount,\n            user_expressions: {},\n        };\n    }\n    async completeRequest(content) {\n        throw new Error('Not implemented');\n    }\n    async inspectRequest(content) {\n        throw new Error('Not implemented');\n    }\n    async isCompleteRequest(content) {\n        throw new Error('Not implemented');\n    }\n    async commInfoRequest(content) {\n        throw new Error('Not implemented');\n    }\n    inputReply(content) { }\n    async commOpen(msg) { }\n    async commMsg(msg) { }\n    async commClose(msg) { }\n}\n"],"names":[],"sourceRoot":""}