"use strict";(self.webpackChunk_jupyter_my_shared_docprovider_extension=self.webpackChunk_jupyter_my_shared_docprovider_extension||[]).push([[349],{349:(e,t,s)=>{s.r(t),s.d(t,{MyProvider:()=>a,MySharedDrive:()=>o});var r=s(602),i=s(421),n=s(262);class a{constructor(e){this._ready=new n.PromiseDelegate,this._isDisposed=!1,this._contentType=e.contentType,this._format=e.format,this._awareness=e.model.awareness,this.model=e.model;const t=e.user;t.ready.then((()=>{this._onUserChanged(t)})).catch((e=>console.error(e))),t.userChanged.connect(this._onUserChanged,this)}setSource(e){this.model.setSource(e),this._ready.resolve()}get isDisposed(){return this._isDisposed}get ready(){return this._ready.promise}get contentType(){return this._contentType}get format(){return this._format}dispose(){this.isDisposed||(this._isDisposed=!0,r.Signal.clearData(this))}_onUserChanged(e){this._awareness.setLocalStateField("user",e.identity)}}class o extends i.Drive{constructor(e,t){super({name:"RTC"}),this._onCreate=e=>{if("string"!=typeof e.format)return this.sharedModelFactory.documentFactories.get(e.contentType)(e);const t=`${e.format}:${e.contentType}:${e.path}`,s=this._providers.get(t);if(s)return s.model;const r=this.sharedModelFactory.documentFactories.get(e.contentType)(e);r.changed.connect(((e,t)=>{t.stateChange||r.ystate.set("dirty",!1)}));const i=new a({path:e.path,format:e.format,contentType:e.contentType,model:r,user:this._user,translator:this._trans});return this._providers.set(t,i),this._app.serviceManager.contents.get(e.path,{content:!0}).then((e=>{let t=e.content;"base64"===e.format?t=atob(t):"json"===e.format&&(t=JSON.stringify(t)),i.setSource(t)})),r.ydoc.on("update",((t,s)=>{s!==this&&this._saveLock.promise.then((()=>{this._saveLock.enable();let t=r.getSource();r.ydoc.transact((()=>{r.ystate.set("dirty",!1)}),this),"text"===e.format&&"object"==typeof t&&(t=JSON.stringify(t)),this._app.serviceManager.contents.save(e.path,{content:t,format:e.format,type:e.contentType}).then((()=>{this._saveLock.disable()}))}))})),r.disposed.connect((()=>{const e=this._providers.get(t);e&&(e.dispose(),this._providers.delete(t))})),r},this._ydriveFileChanged=new r.Signal(this),this._app=e,this._user=e.serviceManager.user,this._trans=t,this._providers=new Map,this.sharedModelFactory=new c(this._onCreate),super.fileChanged.connect(((e,t)=>{this._ydriveFileChanged.emit(t)})),this._saveLock=new h}get providers(){return this._providers}dispose(){this.isDisposed||(this._providers.forEach((e=>e.dispose())),this._providers.clear(),super.dispose())}async get(e,t){if(t&&t.format&&t.type){const s=`${t.format}:${t.type}:${e}`,r=this._providers.get(s);if(r){const[s]=await Promise.all([await this._app.serviceManager.contents.get(e,{...t,content:!1}),r.ready]);return{...s,format:t.format}}}return await this._app.serviceManager.contents.get(e,t)}async listCheckpoints(e){return[]}async createCheckpoint(e){return{id:"",last_modified:""}}async rename(e,t){return await this._app.serviceManager.contents.rename(e,t)}async delete(e){return await this._app.serviceManager.contents.delete(e)}async newUntitled(e){return await this._app.serviceManager.contents.newUntitled(e)}async save(e,t={}){if(t.format&&t.type){const s=`${t.format}:${t.type}:${e}`;if(this._providers.get(s)){const s={type:t.type,format:t.format,content:!1};return this.get(e,s)}}return this._app.serviceManager.contents.save(e,t)}get fileChanged(){return this._ydriveFileChanged}}class c{constructor(e){this._onCreate=e,this.collaborative=!0,this.documentFactories=new Map}registerDocumentFactory(e,t){if(this.documentFactories.has(e))throw new Error(`The content type ${e} already exists`);this.documentFactories.set(e,t)}createNew(e){if("string"==typeof e.format){if(this.collaborative&&e.collaborative&&this.documentFactories.has(e.contentType))return this._onCreate(e)}else console.warn(`Only defined format are supported; got ${e.format}.`)}}class h{constructor(){this.disable=()=>{},this.promise=Promise.resolve()}enable(){this.promise=new Promise((e=>this.disable=e))}}}}]);